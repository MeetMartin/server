{"version":3,"sources":["webpack://server/webpack/universalModuleDefinition","webpack://server/./node_modules/@babel/runtime/helpers/asyncToGenerator.js","webpack://server/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://server/./node_modules/@babel/runtime/helpers/objectWithoutProperties.js","webpack://server/./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack://server/./node_modules/@babel/runtime/regenerator/index.js","webpack://server/./node_modules/decode-uri-component/index.js","webpack://server/./node_modules/filter-obj/index.js","webpack://server/./node_modules/mime-db/index.js","webpack://server/./node_modules/mime-types/index.js","webpack://server/./node_modules/query-string/index.js","webpack://server/./node_modules/regenerator-runtime/runtime.js","webpack://server/./node_modules/split-on-first/index.js","webpack://server/./node_modules/strict-uri-encode/index.js","webpack://server/external \"path\"","webpack://server/webpack/bootstrap","webpack://server/webpack/runtime/compat get default export","webpack://server/webpack/runtime/define property getters","webpack://server/webpack/runtime/hasOwnProperty shorthand","webpack://server/webpack/runtime/make namespace object","webpack://server/./node_modules/@7urtle/lambda/src/arity.js","webpack://server/./node_modules/@7urtle/lambda/src/conditional.js","webpack://server/./node_modules/@7urtle/lambda/src/core.js","webpack://server/./node_modules/@7urtle/lambda/src/utils.js","webpack://server/./node_modules/@7urtle/lambda/src/string.js","webpack://server/./node_modules/@7urtle/lambda/src/list.js","webpack://server/./node_modules/@7urtle/lambda/src/Maybe.js","webpack://server/./node_modules/@7urtle/lambda/src/Either.js","webpack://server/./node_modules/@7urtle/lambda/src/AsyncEffect.js","webpack://server/./node_modules/@7urtle/logger/src/index.js","webpack://server/external \"http\"","webpack://server/./src/RequestEffect.js","webpack://server/external \"fs\"","webpack://server/./src/ResponseEffect.js","webpack://server/./src/Router.js","webpack://server/./src/Server.js","webpack://server/./src/apis/apiError.js","webpack://server/./src/apis/apiFile.js","webpack://server/./src/index.js"],"names":["root","factory","exports","module","define","amd","this","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","fn","self","args","arguments","apply","err","undefined","__esModule","obj","Object","defineProperty","enumerable","configurable","writable","objectWithoutPropertiesLoose","source","excluded","i","target","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","keys","token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","join","left","slice","right","Array","concat","decode","input","tokens","match","encodedURI","TypeError","replace","replaceMap","exec","result","entries","customDecodeURIComponent","predicate","ret","isArr","isArray","val","extensions","types","preference","db","extname","EXTRACT_TYPE_REGEXP","TEXT_TYPE_REGEXP","charset","type","mime","toLowerCase","test","charsets","lookup","contentType","str","extension","exts","create","path","substr","forEach","from","to","strictUriEncode","decodeComponent","splitOnFirst","filterObject","validateArrayFormatSeparator","encode","options","strict","encodeURIComponent","keysSorter","sort","a","b","Number","map","removeHash","hashStart","extract","queryStart","parseValue","parseNumbers","isNaN","trim","parseBooleans","parse","query","assign","arrayFormat","arrayFormatSeparator","formatter","accumulator","includes","isEncodedArray","newValue","item","parserForArrayFormat","param","k","reduce","Boolean","stringify","object","shouldFilter","skipNull","skipEmptyString","index","encoderForArrayFormat","objectCopy","filter","x","parseUrl","url","url_","hash","parseFragmentIdentifier","fragmentIdentifier","stringifyUrl","queryFromUrl","parsedQueryFromUrl","queryString","getHash","pick","exclude","exclusionFilter","runtime","Op","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","state","GenStateSuspendedStart","method","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","GenStateSuspendedYield","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","AsyncIterator","PromiseImpl","invoke","__await","unwrapped","previousPromise","callInvokeWithMethodAndArg","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","toString","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","string","separator","separatorIndex","charCodeAt","toUpperCase","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","d","definition","o","get","prop","r","nary","current","isEqual","isNotEqual","isTrue","deepInspect","isTypeOf","typeOf","isNotTypeOf","isString","isNull","isUndefined","isNumber","isFunction","isLength","isEmpty","anything","getOwnPropertyNames","isNothing","isJust","identity","compose","fns","reduceRight","v","f","mapper","list","functor","flatMap","ap1","ap2","ap","ap3","minusOneToUndefined","lastIndexOf","memory","passThrough","console","log","String","inspectArray","inspect","keysOf","inspectObject","inspectString","regex","limit","start","startsWith","substring","endsWith","upperCaseOf","count","repeat","replacement","search","initial","reducer","checker","acc","find","findIndex","every","end","some","compare","Maybe","Nothing","Just","maybe","onJust","functorMaybe","Either","Success","e","Failure","message","isFailure","isSuccess","either","onFailure","onSuccess","functorEither","AsyncEffect","of","trigger","getAsyncEffect","ofPromise","promise","catch","defaultDecorator","level","Date","toLocaleString","configuration","levels","library","decorator","logRequest","request","logger","debug","sendContent","responseHook","response","content","streamFile","fs","file","on","pipe","writeHead","status","data","contentLength","Buffer","byteLength","getHeaders","sendHead","sendOrStream","emptyContent","ApiEffect","getApiEffect","apiError","any","route","api","routes","lengthOf","MaybeRoute","rawGetApiEffect","listeningListener","port","errorListener","code","respondWithApiError","ResponseEffect","requestListener","requestHook","json","JSON","getRequestObject","RequestEffect","Router","respondToError","http","listeners","listen","listening","_","warn","mimeTypes","size","defaultConfiguration","process","env","getLogger","Server"],"mappings":"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","file":"server.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"server\"] = factory();\n\telse\n\t\troot[\"server\"] = factory();\n})(this, function() {\nreturn ","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\nmodule.exports[\"default\"] = module.exports, module.exports.__esModule = true;","module.exports = require(\"regenerator-runtime\");\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp(token, 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn decodeURIComponent(components.join(''));\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher);\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher);\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\nmodule.exports = function (obj, predicate) {\n\tvar ret = {};\n\tvar keys = Object.keys(obj);\n\tvar isArr = Array.isArray(predicate);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\n\t\tif (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {\n\t\t\tret[key] = val;\n\t\t}\n\t}\n\n\treturn ret;\n};\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\nconst filterObject = require('filter-obj');\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (value === null || value === undefined || value.length === 0) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(query, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn ret;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of query.split('&')) {\n\t\tif (param === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key])) ||\n\t\t(options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const key of Object.keys(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = object[key];\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (url, options) => {\n\toptions = Object.assign({\n\t\tdecode: true\n\t}, options);\n\n\tconst [url_, hash] = splitOnFirst(url, '#');\n\n\treturn Object.assign(\n\t\t{\n\t\t\turl: url_.split('?')[0] || '',\n\t\t\tquery: parse(extract(url), options)\n\t\t},\n\t\toptions && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}\n\t);\n};\n\nexports.stringifyUrl = (object, options) => {\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true\n\t}, options);\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(object.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});\n\n\tconst query = Object.assign(parsedQueryFromUrl, object.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\tlet hash = getHash(object.url);\n\tif (object.fragmentIdentifier) {\n\t\thash = `#${encode(object.fragmentIdentifier, options)}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n\nexports.pick = (input, filter, options) => {\n\toptions = Object.assign({\n\t\tparseFragmentIdentifier: true\n\t}, options);\n\n\tconst {url, query, fragmentIdentifier} = exports.parseUrl(input, options);\n\treturn exports.stringifyUrl({\n\t\turl,\n\t\tquery: filterObject(query, filter),\n\t\tfragmentIdentifier\n\t}, options);\n};\n\nexports.exclude = (input, filter, options) => {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn exports.pick(input, exclusionFilter, options);\n};\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","module.exports = require(\"path\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * nary takes input of a curried function and allows it to be called both as curried and n-ary.\n *\n * @HindleyMilner nary :: (a -> b) -> a -> b\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {nary} from '@7urtle/lambda';\n *\n * const fn1 = nary(a => b => a + b);\n * fn1('a')('b') === fn1('a', 'b'); // => true\n */\nexport const nary = fn =>\n    (...args) => args.length === 0\n        ? fn()\n        : args.reduce((accumulator, current) => accumulator(current), fn);","import {typeOf, lengthOf, deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\n\n/**\n * isEqual output is true if strict equality between a and b is true. isEqual output is always false for comparison\n * of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isEqual} from '@7urtle/lambda';\n *\n * isEqual('something')('something'); // => true\n * isEqual('something')('something else'); // => false\n * isEqual(['a'])(['a']); // => false\n * isEqual({a : 'something'})({a : 'something'}); // => false\n * isEqual([])([]); // => false\n * isEqual([])([]); // => false\n *\n * // isEqual can be called both as a curried unary function or as a standard binary function\n * isEqual('something')('something') === isEqual('something', 'something');\n */\nexport const isEqual = nary(a => b => a === b);\n\n/**\n * isNotEqual output is true if strict equality between a and b is false. isNotEqual output is always true for\n * comparison of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotEqual} from '@7urtle/lambda';\n *\n * isNotEqual('something')('something'); // => false\n * isNotEqual('something')('something else'); // => true\n * isNotEqual(['a'])(['a']); // => true\n * isNotEqual({a : 'something'})({a : 'something'}); // => true\n * isNotEqual([])([]); // => true\n * isNotEqual([])([]); // => true\n *\n * // isNotEqual can be called both as a curried unary function or as a standard binary function\n * isNotEqual('something')('something else') === isNotEqual('something', 'something else');\n */\nexport const isNotEqual = nary(a => b => a !== b);\n\n/**\n * isDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is true including arrays and objects.\n *\n * isDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isDeepEqual} from '@7urtle/lambda';\n *\n * isDeepEqual('something')('something'); // => true\n * isDeepEqual('something')('something else'); // => false\n * isDeepEqual(['a'])(['a']); // => true\n * isDeepEqual({a : 'something'})({a : 'something'}); // => true\n * isDeepEqual([])([]); // => true\n * isDeepEqual([])([]); // => true\n *\n * // isDeepEqual can be called both as a curried unary function or as a standard binary function\n * isDeepEqual('something')('something') === isDeepEqual('something', 'something');\n */\nexport const isDeepEqual = nary(a => b => isEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isNotDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is false including arrays and objects.\n *\n * isNotDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotDeepEqual} from '@7urtle/lambda';\n *\n * isNotDeepEqual('something')('something'); // => false\n * isNotDeepEqual('something')('something else'); // => true\n * isNotDeepEqual(['a', 'b'])(['a']); // => true\n * isNotDeepEqual({a : 'something', b: c => c})({a : 'something'}); // => true\n * isNotDeepEqual([])([]); // => false\n * isNotDeepEqual([])([]); // => false\n *\n * // isNotDeepEqual can be called both as a curried unary function or as a standard binary function\n * isNotDeepEqual('something')('something else') === isNotDeepEqual('something', 'something else');\n */\nexport const isNotDeepEqual = nary(a => b => isNotEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isTrue output is true if input is true.\n *\n * @HindleyMilner isTrue :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isTrue} from '@7urtle/lambda';\n *\n * isTrue(true); // => true\n * isTrue(false); // => false\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse output is true if input is false.\n *\n * @HindleyMilner isFalse :: a -> Boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isFalse} from '@7urtle/lambda';\n *\n * isFalse(true); // => false\n * isFalse(false); // => true\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan output is true if b is greater than a.\n *\n * isGreaterThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isGreaterThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isGreaterThan} from '@7urtle/lambda';\n *\n * isGreaterThan(1)(2); // => true\n * isGreaterThan(3)(2); // => false\n *\n * // isGreaterThan can be called both as a curried unary function or as a standard binary function\n * isGreaterThan(1)(2) === isGreaterThan(1, 2);\n */\nexport const isGreaterThan = nary(a => b => b > a);\n\n/**\n * isLessThan output is true if b is less than a.\n *\n * isLessThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isLessThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLessThan} from '@7urtle/lambda';\n *\n * isLessThan(1)(2); // => false\n * isLessThan(3)(2); // => true\n *\n * // isLessThan can be called both as a curried unary function or as a standard binary function\n * isLessThan(3)(2) === isLessThan(3, 2);\n */\nexport const isLessThan = nary(a => b => b < a);\n\n/**\n * isAtLeast output is true if b is greater or equal to a.\n *\n * isAtLeast can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtLeast :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtLeast} from '@7urtle/lambda';\n *\n * isAtLeast(1)(2); // => true\n * isAtLeast(2)(2); // => true\n * isAtLeast(3)(2); // => false\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtLeast(1)(2) === isAtLeast(1, 2);\n */\nexport const isAtLeast = nary(a => b => b >= a);\n\n/**\n * isAtMost output is true if b is less or equal to a.\n *\n * isAtMost can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtMost :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtMost} from '@7urtle/lambda';\n *\n * isAtMost(1)(2); // => false\n * isAtMost(2)(2); // => true\n * isAtMost(3)(2); // => true\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtMost(3)(2) === isAtMost(31, 2);\n */\nexport const isAtMost = nary(a => b => b <= a);\n\n/**\n * isTypeOf output is true if b is a type of a.\n *\n * isTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isTypeOf} from '@7urtle/lambda';\n *\n * isTypeOf('number')(1); // => true\n * isTypeOf('string')(1); // => false\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * isTypeOf('number')(1) === isTypeOf('number', 1);\n */\nexport const isTypeOf = nary(a => b => isEqual(typeOf(b))(a));\n\n/**\n * isNotTypeOf output is true if b is not a type of a.\n *\n * isNotTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotTypeOf} from '@7urtle/lambda';\n *\n * isNotTypeOf('number')(1); // => false\n * isNotTypeOf('string')(1); // => true\n *\n * // isNotTypeOf can be called both as a curried unary function or as a standard binary function\n * isNotTypeOf('string')(1) === isNotTypeOf('string', 1);\n */\nexport const isNotTypeOf = nary(a => b => isNotEqual(typeOf(b))(a));\n\n/**\n * isString output is true if input is a string.\n *\n * @HindleyMilner isString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isString} from '@7urtle/lambda';\n *\n * isString('string'); // => true\n * isString(1); // => false\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isNotString output is true if input is not a string.\n *\n * @HindleyMilner isNotString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotString} from '@7urtle/lambda';\n *\n * isNotString('string'); // => false\n * isNotString(1); // => true\n */\nexport const isNotString = isNotTypeOf('string');\n\n/**\n * isBoolean output is true if input is a boolean.\n *\n * @HindleyMilner isBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isBoolean} from '@7urtle/lambda';\n *\n * isBoolean(false); // => true\n * isBoolean(1); // => false\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNotBoolean output is true if input is not a boolean.\n *\n * @HindleyMilner isNotBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotBoolean} from '@7urtle/lambda';\n *\n * isNotBoolean(false); // => false\n * isNotBoolean(1); // => true\n */\nexport const isNotBoolean = isNotTypeOf('boolean');\n\n/**\n * isNull output is true if input is a null.\n *\n * @HindleyMilner isNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNull} from '@7urtle/lambda';\n *\n * isNull(null); // => true\n * isNull(1); // => false\n */\nexport const isNull = isEqual(null);\n\n/**\n * isNotNull output is true if input is not a null.\n *\n * @HindleyMilner isNotNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNull} from '@7urtle/lambda';\n *\n * isNotNull(null); // => false\n * isNotNull(1); // => true\n */\nexport const isNotNull = isNotEqual(null);\n\n/**\n * isUndefined output is true if input is an undefined.\n *\n * @HindleyMilner isUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isUndefined} from '@7urtle/lambda';\n *\n * isUndefined(undefined); // => true\n * isUndefined(1); // => false\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNotUndefined output is true if input is not an undefined.\n *\n * @HindleyMilner isNotUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotUndefined} from '@7urtle/lambda';\n *\n * isNotUndefined(undefined); // => false\n * isNotUndefined(1); // => true\n */\nexport const isNotUndefined = isNotTypeOf('undefined');\n\n/**\n * isNumber output is true if input is a number.\n *\n * @HindleyMilner isNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNumber} from '@7urtle/lambda';\n *\n * isNumber(1); // => true\n * isNumber('string'); // => false\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isNotNumber output is true if input is not a number.\n *\n * @HindleyMilner isNotNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNumber} from '@7urtle/lambda';\n *\n * isNotNumber(1); // => false\n * isNotNumber('string'); // => true\n */\nexport const isNotNumber = isNotTypeOf('number');\n\n/**\n * isObject output is true if b is an object, array, or null.\n *\n * @HindleyMilner isObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isObject} from '@7urtle/lambda';\n *\n * isObject({}); // => true\n * isObject([]); // => true\n * isObject(null); // => true\n * isObject(1); // => false\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isNotObject output is true if input is not an object, array, or null.\n *\n * @HindleyMilner isNotObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotObject} from '@7urtle/lambda';\n *\n * isNotObject({}); // => false\n * isNotObject([]); // => false\n * isNotObject(null); // => false\n * isNotObject(1); // => true\n */\nexport const isNotObject = isNotTypeOf('object');\n\n/**\n * isArray output is true if input is an array.\n *\n * @HindleyMilner isArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isArray} from '@7urtle/lambda';\n *\n * isArray([]); // => true\n * isArray({}); // => false\n */\nexport const isArray = Array.isArray;\n\n/**\n * isNotArray output is true if input is not an array.\n *\n * @HindleyMilner isNotArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotArray} from '@7urtle/lambda';\n *\n * isNotArray([]); // => false\n * isNotArray({}); // => true\n */\nexport const isNotArray = a => !Array.isArray(a);\n\n/**\n * isFunction output is true if input is a function.\n *\n * @HindleyMilner isFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isFunction} from '@7urtle/lambda';\n *\n * isFunction(() => null); // => true\n * isFunction(1); // => false\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isNotFunction output is true if input is not a function.\n *\n * @HindleyMilner isNotFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotFunction} from '@7urtle/lambda';\n *\n * isNotFunction(() => null); // => false\n * isNotFunction(1); // => true\n */\nexport const isNotFunction = isNotTypeOf('function');\n\n/**\n * isLength output is true if b is a length of a.\n *\n * @HindleyMilner isLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLength} from '@7urtle/lambda';\n *\n * isLength(3)('abc'); // => true\n * isLength(3)([1,2,3]); // => true\n * isLength(3)('abc'); // => false\n */\nexport const isLength = nary(a => b => isEqual(lengthOf(b))(a));\n\n/**\n * isNotLength output is true if b is not a length of a.\n *\n * @HindleyMilner isNotLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isNotLength} from '@7urtle/lambda';\n *\n * isNotLength(3)('abc'); // => false\n * isNotLength(3)([1,2,3]); // => false\n * isNotLength(3)('abc'); // => true\n */\nexport const isNotLength = nary(a => b => !isLength(a)(b));\n\n/**\n * isEmpty output is true if input is an empty string, array, or object. Otherwise it is false.\n *\n * @HindleyMilner isEmpty :: (string|array) -> boolean\n *\n * @pure\n * @param {string|array|object} anything\n * @return {boolean}\n *\n * @example\n * import {isEmpty} from '@7urtle/lambda';\n *\n * isEmpty(''); // => true\n * isEmpty([]); // => true\n * isEmpty({}); // => true\n * isEmpty('abc'); // => false\n */\nexport const isEmpty = anything =>\n    isLength(0)(anything) ||\n    (isObject(anything) ? isLength(0)(Object.getOwnPropertyNames(anything)) : false);\n\n/**\n * isNotEmpty output is false if input is an empty string, array, or object. Otherwise it is true.\n *\n * @HindleyMilner isNotEmpty :: (string|array) -> boolean\n *\n * @pure\n * @param {string|array|object} anything\n * @return {boolean}\n *\n * @example\n * import {isNotEmpty} from '@7urtle/lambda';\n *\n * isNotEmpty(''); // => false\n * isNotEmpty([]); // => false\n * isNotEmpty('abc'); // => true\n * isNotEmpty({}); => true\n */\nexport const isNotEmpty = anything => !isEmpty(anything);\n\n/**\n * isZero output is true if input is 0.\n *\n * @HindleyMilner isZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => true\n * isZero(1); // => false\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero output is true if input is not 0.\n *\n * @HindleyMilner isNotZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => false\n * isZero(1); // => true\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing returns true if input is null, undefined or empty string or empty array or empty object.\n *\n * @HindleyMilner isNothing :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isNothing} from '@7urtle/lambda';\n *\n * isNothing(null); // => true\n * isNothing(undefined); // => true\n * isNothing(''); // => true\n * isNothing([]); // => true\n * isNothing({}); // => true\n * isNothing('7urtle'); // => false\n */\nexport const isNothing = anything => isNull(anything) || isUndefined(anything) || isEmpty(anything);\n\n/**\n * isJust returns true if input is not null, undefined or empty string or empty array or empty object.\n *\n * @HindleyMilner isJust :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isJust} from '@7urtle/lambda';\n *\n * isJust(null); // => false\n * isJust(undefined); // => false\n * isJust(''); // => false\n * isJust([]); // => false\n * isJus({}); // => false\n * isJust('7urtle'); // => true\n */\nexport const isJust = anything => !isNothing(anything);","import {reduce, reduceRight, filterMap} from './list';\nimport {isString, isArray, isObject, isNotArray} from './conditional';\nimport {minusOneToUndefined, passThrough} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * identity is a function that simply passes its input to its output without changing it.\n *\n * @HindleyMilner identity :: a -> a\n *\n * @pure\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {identity} from '@7urtle/lambda';\n *\n * identity('anything');\n * // => anything\n */\nexport const identity = anything => anything;\n\n/**\n * compose is a right-to-left function composition\n * where each function receives input and hands over its output to the next function.\n *\n * compose executes functions in reverse order to pipe.\n *\n * compose(f,g)(x) is equivalent to f(g(x)).\n *\n * @HindleyMilner compose :: [(a -> b)] -> a -> b\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {compose} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = value => compose(addA, addB)(value);\n *\n * addAB('Order: ');\n * // => Order: BA\n */\nexport const compose = (...fns) => anything => reduceRight(anything)((v, f) => f(v))(fns);\n\n/**\n * pipe output is a left-to-right function composition\n * where each function receives input and hands over its output to the next function.\n *\n * pipe executes functions in reverse order to compose.\n *\n * pipe(f,g)(x) is equivalent to g(f(x)).\n *\n * @HindleyMilner pipe :: [(a -> b)] -> a -> b\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {pipe} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = value => pipe(addA, addB)(value);\n *\n * addAB('Order: ');\n * // => Order: AB\n */\nexport const pipe = (...fns) => anything => reduce(anything)((v, f) => f(v))(fns);\n\n/**\n * map executes mapper function over input array or monad and outputs the resulting array or monad.\n *\n * In case of monads, you should use map when you want to work with functors using functions\n * and functional composition rather than calling Functor.map.\n *\n * If you need to both filter and map over an array, consider using the filterMap function.\n *\n * map can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner map :: (a -> b) -> a -> b\n *\n * @param {function} fn\n * @param {array|functor} target\n * @return {array|functor}\n *\n * @example\n * import {map, Maybe, upperCaseOf} from '@7urtle/lambda';\n *\n * const mapper = a => a + 'm';\n * const list = ['a', 'b', 'c'];\n *\n * // the function mapper is applied to each member of the array\n * map(mapper)(list); // => ['am', 'bm', 'cm']\n *\n * // the function upperCaseOf is applied to the value of the functor\n * map(upperCaseOf)(Maybe.of('something')); // => Just('SOMETHING')\n *\n * // use of map equals the use of map on the functor\n * map(upperCaseOf)(Maybe.of('something')).value === Maybe.of('something').map(upperCaseOf).value;\n *\n * // map can be called both as a curried unary function or as a standard binary function\n * map(upperCaseOf)(Maybe.of('something')).value === map(upperCaseOf, Maybe.of('something')).value;\n */\nexport const map = nary(mapper => list => list.map(mapper));\n\n/**\n * flatMap maps function over inputted functor outputting resulting flattened functor.\n *\n * You should use flatMap when you want to work with functors using functions\n * and functional composition rather than calling flatMaps.\n *\n * The function can be called both as a unary flatMap(fn)(functor) and binary flatMap(fn, functor).\n *\n * @HindleyMilner flatMap :: (a -> Functor) -> Functor -> Functor\n *\n * @param {function} fn\n * @param {functor} functor\n * @return {functor}\n *\n * @example\n * import {flatMap, map, Maybe} from '@7urtle/lambda';\n *\n * const maybePlus2 = number => Maybe.of(number + 2);\n *\n * // the function maybePlus2 is applied to the value of the functor\n * flatMap(maybePlus2)(Maybe.of(3)); // => Just(5)\n * map(maybePlus2)(Maybe.of(3)); // => Just(Just(5))\n *\n * // use of flatMap equals the use of flatMap on the functor\n * flatMap(maybePlus2)(Maybe.of(3)).value === Maybe.of(3).flatMap(maybePlus2).value;\n *\n * // flatMap can be called both as a curried unary function or as a standard binary function\n * flatMap(maybePlus2)(Maybe.of(3)).value === flatMap(maybePlus2, Maybe.of(3)).value;\n */\nexport const flatMap = nary(fn => functor => functor.flatMap(fn));\n\n/**\n * liftA2 provides point-free way of writing calls over applicative functors and functions expecting 2 inputs. It\n * applies input function over both functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA2(fn)(functor)(functor) and ternary liftA2(fn, functor, functor).\n *\n * @HindleyMilner liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @return {functor}\n *\n * @example\n * import {liftA2, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => a + b;\n *\n * // function add which expects two inputs is applied to the values of two applicative functors Maybe\n * // the result is a Maybe functor with the internal value 5\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA2(add)(Maybe.of(1))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA2 can be called both as a curried unary function or as a standard ternary function\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)).value === liftA2(add, Maybe.of(2), Maybe.of(3)).value;\n */\nexport const liftA2 = nary(fn => ap1 => ap2 => ap1.map(fn).ap(ap2));\n\n/**\n * liftA3 provides point-free way of writing calls over applicative functors and functions expecting 3 inputs. It\n * applies input function over input functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA3(fn)(functor)(functor)(functor) and quaternary liftA2(fn, functor, functor, functor).\n *\n * @HindleyMilner liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @param {functor} ap3\n * @return {functor}\n *\n * @example\n * import {liftA3, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => c => a + b + c;\n *\n * // function add which expects three inputs is applied to the values of three applicative functors Maybe\n * // the result is a Maybe functor with the internal value 9\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)); // => Just(9)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA3(add)(Maybe.of(1))(Maybe.of(2))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA3 can be called both as a curried unary function or as a standard quaternary function\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)).value === liftA3(add, Maybe.of(2), Maybe.of(3), Maybe.of(4)).value;\n */\nexport const liftA3 = nary(fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3));\n\n/**\n * contact outputs concatenated inputs of strings, arrays and shallow objects or outputs undefined for other types.\n *\n * concat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner concat :: a -> a|boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {concat} from '@7urtle/lambda';\n *\n * concat('cd')('ab'); // => 'abcd'\n * concat([3, 4])([1,2]); // => [1, 2, 3, 4]\n * concat({here: {here: 'there'}})({hi: 'hello'}); // => {hi: 'hello', here: {here: 'there'}}\n * concat('cd')(1); // => undefined\n *\n * // concat can be called both as a curried unary function or as a standard binary function\n * concat('cd')('ab') === concat('cd', 'ab');\n */\nexport const concat = nary(a => b =>\n  isString(b) || isArray(b)\n    ? b.concat(a)\n    : isObject(b)\n      ? {...b, ...a}\n      : undefined);\n\n/**\n * merge performs a deep merge on all input objects and arrays.\n *\n * @HindleyMilner merge :: [a] -> [b]\n *\n * @pure\n * @param {array|object} sources\n * @return {array|object}\n *\n * @example\n * import {merge} from '@7urtle/lambda';\n *\n * const obj1 = { a: 'a', c: ['a'] };\n * const obj2 = { b: a => a, d: ['a', 'b'] };\n * const obj3 = { a: 'c', c: ['c'] };\n *\n * merge(obj1, obj2, obj3));\n * // => {\"a\": \"c\", \"b\": a => a, \"c\": [\"a\", \"c\"], \"d\": [\"a\", \"b\"]}\n *\n * const list1 = ['a', 'b'];\n * const list2 = [1, 2];\n *\n * merge(list1,list2);\n * // => ['a', 'b', 1, 2]\n */\nexport const merge = (...sources) =>\n    reduce\n    ([])\n    ((acc, current) =>\n        isArray(current)\n            ? [...acc, ...current]\n            : isObject(current)\n            ? reduce\n            (acc)\n            ((a, c) =>\n                isObject(current[c]) && c in acc\n                    ? {...a, [c]: merge(acc[c], current[c])}\n                    : {...a, [c]: current[c]}\n            )\n            (Object.getOwnPropertyNames(current))\n            : {...acc, ...current}\n    )\n    (sources);\n\n/**\n * includes(a)(b) output is true if b includes a.\n *\n * includes can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner includes :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {includes} from '@7urtle/lambda';\n *\n * includes('rt')('7urtle'); // => true\n * includes(1)([1, 2, 3]) // => true\n * includes('turtle')([1, 2, 3]) // => false\n *\n * // includes can be called both as a curried unary function or as a standard binary function\n * includes('rt')('7urtle') === includes('rt', '7urtle');\n */\nexport const includes = nary(a => b => b.includes(a));\n\n/**\n * indexOf(a)(b) outputs position of input a within input b or undefined if it is not found.\n *\n * indexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner indexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {indexOf} from '@7urtle/lambda';\n *\n * indexOf('7')('7urtle'); // => 0\n * indexOf(7)('7urtle'); // => 0\n * indexOf(2)([1, 2, 3]); // => 1\n * indexOf(4)([1, 2, 3]); // => undefined\n *\n * // indexOf can be called both as a curried unary function or as a standard binary function\n * indexOf('7')('7urtle') === indexOf('7', '7urtle');\n */\nexport const indexOf = nary(a => b => minusOneToUndefined(b.indexOf(a)));\n\n/**\n * lastIndexOf(a)(b) outputs position of input a withing input b looking from the end or it retuns undefined if it is not found.\n *\n * lastIndexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner lastIndexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {lastIndexOf} from '@7urtle/lambda';\n *\n * lastIndexOf('urtle')('7urtle'); // => 1\n * lastIndexOf(2)([1, 2, 3, 2]); // => 3\n * lastIndexOf('8')('7urtle'); // => undefined\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard binary function\n * lastIndexOf('7')('7urtle') === lastIndexOf('7', '7urtle');\n */\nexport const lastIndexOf = nary(a => b => minusOneToUndefined(b.lastIndexOf(a)));\n\n/**\n * memoize uses input memory to save output of input function and then uses it to lookup the result on a repeated run. This\n * function is not pure because the input memory is modified in the process.\n *\n * The function can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner memoize :: object -> (a -> b) -> a -> b\n *\n * @param {object} memory\n * @param {function} fn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {memoize} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * let memory = {};\n *\n * memoize(memory)(addTwo)(1); // => 3\n * memoize(memory)(addTwo)(1); // => 3\n * memory[1]; // => 3\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard ternary function\n * memoize(memory)(addTwo)(1) === memoize(memory, addTwo, 1);\n */\nexport const memoize = nary(memory => fn => anything =>\n    anything in memory\n        ? memory[anything]\n        : passThrough(b => memory[anything] = b)(fn(anything))\n);\n\n/**\n * memo takes input function and returns it enhanced by memoization which ensures that each result is\n * always remembered internally and executed only once.\n *\n * @HindleyMilner memo :: (a -> b) -> (a -> b)\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {memo} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * const memoAddTwo = memo(addTwo);\n * const memoAddThree = memo(a => a + 3);\n *\n * memoAddTwo(1); // => 3\n * memoAddThree(1); // => 4\n *\n * let count = 0;\n * const increaseCount = () => ++count;\n *\n * increaseCount(); // 1\n * increaseCount(); // 2\n *\n * const memoIncreaseCount = memo(increaseCount);\n *\n * memoIncreaseCount(); // 3\n * memoIncreaseCount(); // 3\n * memoIncreaseCount(); // 3\n */\nexport const memo = fn => memoize({})(fn);","import {isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined, isGreaterThan} from \"./conditional\";\nimport {keysOf, join} from \"./list\";\nimport {map} from \"./core\";\nimport {nary} from \"./arity\";\n\n/**\n * typeOf outputs a type of its input.\n *\n * @HindleyMilner typeOf :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {typeOf} from '@7urtle/lambda';\n *\n * typeOf('7turtle'); // => 'string'\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf outputs the length of an input.\n *\n * @HindleyMilner lengthOf :: (string|array) -> number\n *\n * @pure\n * @param {string|array} a\n * @return {number}\n *\n * @example\n * import {lengthOf} from '@7urtle/lambda';\n *\n * lengthOf('7turtle'); // => 7\n * lengthOf([1,2,3]); // => 3\n * lengthOf({}); // => undefined\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough output is the same as input a. passThrough executes function passed as first argument.\n *\n * passThrough can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner passThrough :: function -> a -> a\n *\n * @pure\n * @param {function} fn\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {passThrough} from '@7urtle/lambda';\n *\n * passThrough(() => 'b')('a'); // => 'a'\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * passThrough(() => 'b')('a') === passThrough(() => 'b', 'a');\n */\nexport const passThrough = nary(fn => anything => {\n  fn(anything);\n  return anything;\n});\n\n/**\n * log output is the same as input and it logs the input value. log causes side effect of console.log.\n *\n * @HindleyMilner log :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * log('anything'); // => 'anything'\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy output is the same as input and it logs the deepInspect of the input. spy causes side effect of console.log.\n *\n * @HindleyMilner spy :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {spy} from '@7urtle/lambda';\n *\n * spy([1, 'a']); // => \"[1, 'a']\"\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n *\n * Because some functions return -1 as error state, this function is created to change it into a more consistent\n * undefined output.\n *\n * @HindleyMilner minusOneToUndefined :: a -> a|boolean\n *\n * @pure\n * @param {*} anything\n * @return {*|boolean}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * minusOneToUndefined(-1); // => undefined\n * minusOneToUndefined(0); // => 0\n * minusOneToUndefined('7urtle'); // => '7urtle'\n */\nexport const minusOneToUndefined = anything => isEqual(-1)(anything) ? undefined: anything;\n\n/**\n * inspectFunction outputs name of named function or its conversion to string.\n *\n * @HindleyMilner inspectFunction :: (a -> b) -> string\n *\n * @pure\n * @param {function} fn\n * @return {string}\n *\n * @example\n * import {inspectFunction} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectFunction(namedFunction); // => 'namedFunction'\n * inspectFunction(() => 'b');\n * // => `function () {\n * // =>     return 'b';\n * // => }`\n */\nexport const inspectFunction = fn => fn.name ? fn.name : String(fn);\n\n/**\n * inspectArray maps over input array [a] and outputs string representing it.\n *\n * @HindleyMilner inspectArray :: [a] -> string\n *\n * @pure\n * @param {array} a\n * @return {string}\n *\n * @example\n * import {inspectArray} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectArray([1, 'a']); // => \"[1, 'a']\"\n * inspectArray([namedFunction, 'a']); // => \"[namedFunction, 'a']\"\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString outputs string representing input.\n *\n * @HindleyMilner inspectString :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {inspectString} from '@7urtle/lambda';\n *\n * inspectString('my string'); // => \"'my string'\"\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject outputs string representing input.\n *\n * @HindleyMilner inspectObject :: a -> string\n *\n * @pure\n * @param {object} a\n * @return {string}\n *\n * @example\n * import {inspectObject} from '@7urtle/lambda';\n *\n * inspectObject({a: 'b'}); // => \"{a: 'b'}\"\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect runs recursively over input and outputs string representing the input.\n *\n * @HindleyMilner deepInspect :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {deepInspect} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * deepInspect({a: 'b'}); // => \"{a: 'b'}\"\n * deepInspect(namedFunction); // => 'namedFunction'\n * deepInspect([1, 'a']); // => \"[1, 'a']\"\n * deepInspect('my string'); // => \"'my string'\"\n * deepInspect(undefined); // => 'undefined'\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils';\nimport {nary} from \"./arity\";\n\n/**\n * trim output is a string without white characters around it.\n *\n * @HindleyMilner trim :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {trim} from '@7urtle/lambda';\n *\n * trim(' a \\n '); // => 'a'\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx outputs true if string b passes regular expression a.\n *\n * testRegEx can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner testRegEx :: regex -> string -> boolean\n *\n * @pure\n * @param {regex} regex\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {testRegEx} from '@7urtle/lambda';\n *\n * testRegEx(/[a-z]/)('7urtle'); // => true\n * testRegEx(/[0-9]/)('1'); // => true\n * testRegEx(/[0-9]/)('abc'); // => false\n *\n * // testRegEx can be called both as a curried unary function or as a standard binary function\n * testRegEx(/[a-z]/)('7urtle') === testRegEx(/[a-z]/, '7urtle');\n */\nexport const testRegEx = nary(regex => string => regex.test(string));\n\n/**\n * substr outputs substring based on provided string, start and limit.\n *\n * substr can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner substr :: number -> number -> string -> string\n *\n * @pure\n * @param {number} limit\n * @param {number} start\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {substr} from '@7urtle/lambda';\n *\n * substr(3)(1)('7urtle'); // => 'urt'\n * substr(1)(0)('7urtle'); // => '7'\n * substr(1)(-1)('7urtle'); // => 'e'\n *\n * // substr can be called both as a curried unary function or as a standard ternary function\n * substr(3)(1)('7urtle') === substr(3, 1, '7urtle');\n */\nexport const substr = nary(limit => start => string => string.substr(start, limit));\n\n/**\n * firstLetterOf outputs the first letter of a provided string.\n *\n * @HindleyMilner firstLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {firstLetterOf} from '@7urtle/lambda';\n *\n * firstLetterOf('7urtle'); // => '7'\n */\nexport const firstLetterOf = string => string.substr(0, 1);\n\n/**\n * lastLetterOf outputs the last letter of a provided string.\n *\n * @HindleyMilner lastLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lastLetterOf} from '@7urtle/lambda';\n *\n * lastLetterOf('7urtle'); // => 'e'\n */\nexport const lastLetterOf = string => string.substr(-1, 1);\n\n/**\n * startsWith outputs true if an input string starts with provided string.\n *\n * startsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner startsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {startsWith} from '@7urtle/lambda';\n *\n * startsWith('7')('7urtle'); // => true\n * startsWith('7urtl')('7urtle'); // => true\n * startsWith('8urtl')('7urtle'); // => false\n *\n * // startsWith can be called both as a curried unary function or as a standard binary function\n * startsWith('7')('7urtle') === startsWith('7', '7urtle');\n */\nexport const startsWith = nary(substring => string => string.startsWith(substring));\n\n/**\n * endsWith outputs true if an input string ends with provided string.\n *\n * endsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner endsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {endsWith} from '@7urtle/lambda';\n *\n * endsWith('7e')('7urtle'); // => true\n * endsWith('urtle')('7urtle'); // => true\n * endsWith('urtls')('7urtle'); // => false\n *\n * // endsWith can be called both as a curried unary function or as a standard binary function\n * endsWith('e')('7urtle') === endsWith('e', '7urtle');\n */\nexport const endsWith = nary(substring => string => string.endsWith(substring));\n\n/**\n * repeat outputs new string repeating input string inputted count of times.\n *\n * repeat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner repeat :: number -> string -> string\n *\n * @pure\n * @param {number} count\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {repeat} from '@7urtle/lambda';\n *\n * repeat(2)('7urtle'); // => '7urtle7urtle'\n * repeat(0)('7urtle'); // => ''\n *\n * // repeat can be called both as a curried unary function or as a standard binary function\n * repeat(2)('7urtle') === repeat(2, '7urtle');\n */\nexport const repeat = nary(count => string => string.repeat(count));\n\n/**\n * replace outputs new string replacing input substring with input replacement string in input string.\n *\n * replace can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner replace :: string -> string -> string -> string\n *\n * @pure\n * @param {string} replacement\n * @param {string} substring\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {replace} from '@7urtle/lambda';\n *\n * replace('8')('7')('7urtle'); // => '8urtle'\n * replace('7')('')('7urtle'); // => '77urtle'\n * replace('')('7')('7urtle'); // => 'urtle'\n *\n * // replace can be called both as a curried unary function or as a standard ternary function\n * replace('8')('7')('7urtle') === replace('8', '7', '7urtle');\n */\nexport const replace = nary(replacement => substring => string => string.replace(substring, replacement));\n\n/**\n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n *\n * search can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner search :: string/regex -> string -> number\n *\n * @pure\n * @param {string|regex} substring\n * @param {string} string\n * @return {number}\n *\n * @example\n * import {search} from '@7urtle/lambda';\n *\n * search('7')('7urtle'); 0\n * search('e')('7urtle'); // => 5\n * search('rt')('7urtle'); // => 2\n * search(/URT/i)('7urtle'); // => 1\n * search('8')('7urtle'); => undefined\n *\n * // search can be called both as a curried unary function or as a standard binary function\n * search('7')('7urtle') === search('7', '7urtle');\n */\nexport const search = nary(substring => string => minusOneToUndefined(string.search(substring)));\n\n/**\n * split outputs and array of an input string split by the input substring.\n *\n * split can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner split :: string -> string -> array\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {array}\n *\n * @example\n * import {split} from '@7urtle/lambda';\n *\n * split(' ')('7urtles are awesome'); // => ['7urtles', 'are', 'awesome']\n * split('/')('7urtles are awesome'); // => ['7urtles are awesome']\n *\n * // split can be called both as a curried unary function or as a standard binary function\n * split(' ')('7urtles are awesome') === split(' ', '7urtles are awesome');\n */\nexport const split = nary(substring => string => string.split(substring));\n\n/**\n * lowerCaseOf outputs the lower case version of input string.\n *\n * @HindleyMilner lowerCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lowerCaseOf} from '@7urtle/lambda';\n *\n * lowerCaseOf('PeTrA'); // => 'petra'\n * lowerCaseOf('PERN LUOUK K PL BELSK DY'); // => 'pern luouk k pl belsk dy'\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf outputs the upper case version of input string.\n *\n * @HindleyMilner upperCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {upperCaseOf} from '@7urtle/lambda';\n *\n * upperCaseOf('PeTrA'); // => 'PETRA'\n * upperCaseOf('pern luouk k pl belsk dy'); // => 'PERN LUOUK K PL BELSK DY'\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {lengthOf, minusOneToUndefined} from './utils';\nimport {nary} from \"./arity\";\nimport {upperCaseOf} from \"./string\";\nimport {concat, merge} from \"./core\";\n\n/**\n * reduce executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduce executes functions in reverse order to reduceRight.\n *\n * reduce can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduce} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduce('start')(reducer)(list); // => startabc\n *\n * // reduce can be called both as a curried unary function or as a standard ternary function\n * reduce('start')(reducer)(list) === reduce('start', reducer, list);\n */\nexport const reduce = nary(initial => reducer => list => list.reduce(reducer, initial));\n\n/**\n * reduceRight executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduceRight executes functions in reverse order to reduce.\n *\n * reduceRight can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduceRight} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduceRight('start')(reducer)(list); // => startcba\n *\n * // reduceRight can be called both as a curried unary function or as a standard ternary function\n * reduceRight('start')(reducer)(list) === reduceRight('start', reducer, list);\n */\nexport const reduceRight = nary(initial => reducer => list => list.reduceRight(reducer, initial));\n\n/**\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n *\n * If you need to both filter and map over an array, consider using the filterMap function.\n *\n * filter can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner filter :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filter} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * filter(a => a > 1)(list); // => [2, 3]\n *\n * // filter can be called both as a curried unary function or as a standard binary function\n * filter(a => a > 1)(list) === filter(a => a > 1, list);\n */\nexport const filter = nary(checker => list => list.filter(checker));\n\n/**\n * filterMap executes mapper function over filtered input array or monad and outputs the resulting array or monad.\n *\n * Only one pass through the array is executed unlike the use of map(mapper)(filter(checker)(list)).\n *\n * filterMap can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner filterMap :: (a -> boolean) -> (a -> b) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {function} mapper\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filterMap} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n * const mapper = a => a + 1;\n * const checker = a => a > 1;\n *\n * filterMap(checker)(mapper)(list);  // => [3, 4]\n * filterMap(a => a > 1)(a => a + 1)([0, 1, 2, 3]); // => [3, 4]\n *\n * const mapOverLargerThanOne = filterMap(checker);\n * mapOverLargerThanOne(mapper)(list); // => [3, 4]\n *\n * // filterMap can be called both as a curried unary function or as a standard ternary function\n * filterMap(a => a > 1)(a => a + 1)(list) === filterMap(a => a > 1, a => a + 1, list);\n */\nexport const filterMap = nary(checker => mapper => list =>\n    reduce([])((acc, current) => checker(current) ? acc.push(mapper(current)) && acc : acc)(list));\n\n/**\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n *\n * find can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner find :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {find} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * find(a => a > 1)(list); // => 2\n * find(a => a > 3)(list); // => undefined\n *\n * // find can be called both as a curried unary function or as a standard binary function\n * find(a => a > 1)(list) === find(a => a > 1, list);\n */\nexport const find = nary(checker => list => list.find(checker));\n\n/**\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n *\n * findIndex can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {findIndex} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * findIndex(a => a > 2)(list); // => 1\n * findIndex(a => a > 4)(list); // => undefined\n *\n * // findIndex can be called both as a curried unary function or as a standard binary function\n * findIndex(a => a > 1)(list) === findIndex(a => a > 1, list);\n */\nexport const findIndex = nary(checker => list => minusOneToUndefined(list.findIndex(checker)));\n\n/**\n * join outputs a string created by joining input array members with input separator.\n *\n * join can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner join :: string -> [a] -> string\n *\n * @pure\n * @param {string} separator\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {join} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * join('')(list); // => '234'\n * join(' and ')(list); // => '2 and 3 and 4'\n * join()(list); // => '2,3,4'\n *\n * // join can be called both as a curried unary function or as a standard binary function\n * join('')(list) === join('', list);\n */\nexport const join = nary(separator => list => list.join(separator));\n\n/**\n * keysOf outputs array of string keys of input array or object.\n *\n * @HindleyMilner keysOf :: object -> [string]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {keysOf} from '@7urtle/lambda';\n *\n * keysOf([2, 3, 4]); // => ['0', '1', '2']\n * keysOf({1: 2, 2: 3}); // => ['1', '2']\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n *\n * @HindleyMilner entriesOf :: object -> [[string, a]]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {entriesOf} from '@7urtle/lambda';\n *\n * entriesOf([2, 3, 4]); // => [['0', 2], ['1', 3], ['2', 4]]\n * entriesOf({1: 2, 2: 3}); // => [['1', 2],['2', 3]]\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf outputs true if every element of input array passes input checker function as true.\n *\n * everyOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {everyOf} from '@7urtle/lambda';\n *\n * everyOf(a => a > 1)([2, 3, 4]); // => true\n * everyOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // everyOf can be called both as a curried unary function or as a standard binary function\n * everyOf(a => a > 1)([2, 3, 4]) === everyOf(a => a > 1, [2, 3, 4]);\n */\nexport const everyOf = nary(checker => list => list.every(checker));\n\n/**\n * slice outputs selected array elements as an array based on input range. First argument end\n * represents the ending index (not length) and start represents the starting index in the input\n * array list.\n *\n * slice can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner slice :: number -> number -> [a] -> [a]\n *\n * @pure\n * @param {number} end\n * @param {number} start\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {slice} from '@7urtle/lambda';\n *\n * slice(2)(1)([1, 2, 3, 4, 5]); // => [2]\n * slice(2)(0)([1, 2, 3, 4, 5]); // => [1, 2]\n * slice(8)(7)([1, 2, 3, 4, 5]); // => []\n *\n * // slice can be called both as a curried unary function or as a standard ternary function\n * slice(2)(1)([1, 2, 3, 4, 5]) === slice(2, 1, [1, 2, 3, 4, 5]);\n */\nexport const slice = nary(end => start => list => list.slice(start, end));\n\n/**\n * some outputs true if any element of input array passes input checker function as true.\n *\n * some can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner some :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {some} from '@7urtle/lambda';\n *\n * someOf(a => a > 1)([2, 3, 4]); // => true\n * someOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // some can be called both as a curried unary function or as a standard binary function\n * someOf(a => a > 1)([2, 3, 4]) === someOf(a => a > 1, [2, 3, 4]);\n */\nexport const someOf = nary(checker => list => list.some(checker));\n\n/**\n * sort outputs an array sorted based on input compare function.\n *\n * sort can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner sort :: (a -> number) -> [a] -> [a]\n *\n * @pure\n * @param {function} compare\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sort} from '@7urtle/lambda';\n *\n * sort((a, b) => a < b ? -1 : a > b ? 1 : 0)(['a', 'd', 'c', 'd']); // => ['a', 'c', 'd', 'd']\n * sort((a, b) => a - b)([5, 3, 6]); // => [3, 5, 6]\n *\n * // sort can be called both as a curried unary function or as a standard binary function\n * sort((a, b) => a - b)([5, 3, 6]) === sort((a, b) => a - b, [5, 3, 6]);\n */\nexport const sort = nary(compare => list => [...list].sort(compare));\n\n/**\n * sortAlphabetically outputs an array sorted alphabetically from a to z.\n *\n * @HindleyMilner sortAlphabetically :: [string] -> [string]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortAlphabetically} from '@7urtle/lambda';\n *\n * sortAlphabetically(['petra', 'Martin', 'Petra']); // => ['Martin', 'petra', 'Petra']\n */\nexport const sortAlphabetically = sort((a, b) => (a => b => a < b ? -1 : a > b ? 1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\n\n/**\n * sortAlphabeticallyZA outputs an array sorted alphabetically from z to a.\n *\n * @HindleyMilner sortAlphabeticallyZA :: [string] -> [string]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortAlphabeticallyZA} from '@7urtle/lambda';\n *\n * sortAlphabeticallyZA(['petra', 'Martin', 'Petra']); // => ['petra', 'Petra', 'Martin']\n */\nexport const sortAlphabeticallyZA = sort((a, b) => (a => b => a < b ? 1 : a > b ? -1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\n\n/**\n * sortNumerically outputs an array sorted numerically from 1 to 2.\n *\n * @HindleyMilner sortNumerically :: [number] -> [number]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortNumerically} from '@7urtle/lambda';\n *\n * sortNumerically([3, 4, 1, 3]); // => [1, 3, 3, 4]\n */\nexport const sortNumerically = sort((a, b) => a - b);\n\n/**\n * sortNumerically21 outputs an array sorted numerically from 2 to 1.\n *\n * @HindleyMilner sortNumerically21 :: [number] -> [number]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortNumerically21} from '@7urtle/lambda';\n *\n * sortNumerically21([3, 4, 1, 3]); // => [4, 3, 3, 1]\n */\nexport const sortNumerically21 = sort((a, b) => b - a);\n\n/**\n * headOf outputs the first item (head) from the input array.\n *\n * @HindleyMilner headOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {headOf} from '@7urtle/lambda';\n *\n * headOf([3, 4, 1, 8]); // => 3\n * headOf([8]); // => 8\n */\nexport const headOf = list => list[0];\n\n/**\n * tailOf outputs the the input array without its first item.\n *\n * @HindleyMilner tailOf :: [a] -> []\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {tailOf} from '@7urtle/lambda';\n *\n * tailOf([3, 4, 1, 8]); // => [4, 1, 8]\n * tailOf([8]); // => []\n */\nexport const tailOf = list => list.slice(1);\n\n/**\n * initOf outputs the the input array without its last item.\n *\n * @HindleyMilner initOf :: [a] -> []\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {initOf} from '@7urtle/lambda';\n *\n * initOf([3, 4, 1, 8]); // => [3, 4, 1]\n * initOf([8]); // => []\n */\nexport const initOf = list => slice(lengthOf(list) -1)(0)(list);\n\n/**\n * lastOf outputs the last item from the input array.\n *\n * @HindleyMilner lastOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {lastOf} from '@7urtle/lambda';\n *\n * lastOf([3, 4, 1, 8]); // => 8\n * lastOf([3]); // => 3\n */\nexport const lastOf = list => list[lengthOf(list) -1];\n\n/**\n * groupBy outputs an objects with groups produced by an input function over input list.\n *\n * groupBy can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner groupBy :: (a -> b) -> [a] -> {b: a}\n *\n * @pure\n * @param {function} fn\n * @param {array} list\n * @return {object}\n *\n * @example\n * import {groupBy} from '@7urtle/lambda';\n *\n * groupBy(a => a.length)(['one', 'two', 'three']);\n * // => {\"3\": [\"one\", \"two\"], \"5\": [\"three\"]}\n *\n * groupBy(a => a % 2)([1, 2, 3]);\n * // =>  {\"0\": [2], \"1\": [1, 3]}\n *\n * // groupBy can be called both as a curried unary function or as a standard binary function\n * groupBy(a => a.length)(['one', 'two', 'three']) === groupBy(a => a.length, ['one', 'two', 'three'])\n */\nexport const groupBy = nary(fn => list =>\n    reduce\n    ({})\n    ((acc, current) =>\n        (acc[fn(current)] = acc[fn(current)] || []).push(current) && acc\n    )\n    (list));","import {deepInspect} from \"./utils\";\nimport {isNothing} from \"./conditional\";\nimport {nary} from \"./arity\";\n\n/**\n * Maybe is one of the simplest and well known monads. In other languages or libraries it is also sometimes\n * called Option. Maybe is also quite similar to our monad Either.\n *\n * Maybe expects a value as its input. It is Nothing if the value is null, undefined, or empty. It returns\n * Just for all other cases.\n *\n * Maybe is called Maybe because it maybe holds a value. You want to use Maybe for situations when you don't\n * know whether there is going to be an output. It makes the situation very obvious and forces its consumers\n * to safely deal with it.\n *\n * In other languages, Maybe monad can also be called Option monad or Nullable monad.\n *\n * @example\n * import {maybe, Maybe, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we randomly give Maybe a value or undefined. Maybe.of() outputs an instance of Maybe.\n * const myMaybe = Maybe.of(Math.random() > 0.5 ? 'random success' : undefined);\n *\n * // you could access the actual value like this\n * myMaybe.value; // => 'random success' or undefined\n *\n * // you can also inspect it by\n * myMaybe.inspect(); // => \"Just('random success')\" or \"Nothing\"\n *\n * // you can check if the value is Nothing\n * myMaybe.isNothing(); // => true or false\n * Maybe.of('abc').isNothing(); // => false\n * Maybe.of([]).isNothing(); // => true\n *\n * // you can check if the value is Just\n * myMaybe.isJust(); // => true or false\n * Maybe.of(123).isJust(); // => true\n * Maybe.of(null).isJust(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Nothing)\n * myMaybe.map(value => upperCaseOf(value));\n * myMaybe.inspect(); // => \"Just('RANDOM SUCCESS')\" or \"Nothing\"\n *\n * // as a monad Maybe can be safely flat mapped with other Maybes (flatMap doesn't execute over Nothing)\n * Maybe.of(3).flatMap(a => Maybe.of(a + 2)).inspect(); // => 'Just(5)'\n * Maybe.of(3).flatMap(a => Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(3).flatMap(a => a + 2); // => 5\n *\n * // as an applicative functor you can apply Maybes to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n * Maybe.of(1).map(add).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n * Maybe.of(1).map(add).ap(Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(add).ap(Maybe.of(1)).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n *\n * // as an example you can use Maybe to help you work with DOM like this\n * Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop); // => Just(1240)\n * Maybe.of(document.querySelector('#idontexist')).map(a => a.offsetTop); // => Nothing\n * maybe('error: the object doesnt exist')(a => 'offset from top is ' + a)(Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop))\n */\nexport const Maybe = {\n  of: value => isNothing(value) ? Nothing(value) : Just(value)\n};\n\nconst Nothing = value => ({\n  value: value,\n  inspect: () => 'Nothing',\n  isNothing: () => true,\n  isJust: () => false,\n  map: () => Nothing(value),\n  flatMap: () => Nothing(value),\n  ap: () => Nothing(value)\n});\n\nconst Just = value => ({\n  value: value,\n  inspect: () => `Just(${deepInspect(value)})`,\n  isNothing: () => false,\n  isJust: () => true,\n  map: fn => Maybe.of(fn(value)),\n  flatMap: fn => fn(value),\n  ap: f => f.map(value)\n});\n\n/**\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n *\n * maybe can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner maybe :: a -> (b -> c) -> Maybe -> d\n *\n * @pure\n * @param {*} error\n * @param {function} onJust\n * @param {Maybe} functorMaybe\n * @return {*}\n *\n * @example\n * import {maybe, Maybe} from '@7urtle/lambda';\n *\n * maybe('error')(a => a)(Maybe.of('abc')); // => 'abc'\n * maybe('error')(a => a)(Maybe.of(undefined)); // => 'error'\n * maybe('error')(a => a)(Maybe.of(undefined)) === Maybe.of(undefined).isNothing() ? 'error' ? 'not error';\n *\n * // maybe can be called both as a curried unary function or as a standard ternary function\n * maybe('error')(a => a)(Maybe.of('abc')) === maybe('error', a => a, Maybe.of('abc'));\n */\nexport const maybe = nary(error => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? error\n    : onJust(functorMaybe.value));","import {deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\n\n/**\n * Either is an excellent monad for handling error states and it is fairly similar to our monad Maybe. Either.Failure\n * represents an error state and Either.Success represents a success state.\n *\n * Either.of expects a value as its input. Either.of is the same as Either.Success. You can initiate Either\n * in its error state by Either.Failure.\n *\n * You can also initiate it using Either.try which expects a function as an input. It is Failure if an error\n * or exception is thrown. It is Success if there are no errors or exceptions.\n *\n * Either is called Either because it allows you to branch based on an error state. You want to use Either\n * for situations when you don't know whether there might be an error. It makes the very visible that an error\n * can occur and it forces the consumer to handle the situation.\n *\n * @example\n * import {either, Either, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we randomly give Either a value or throw an error. Either.try() outputs an instance of Either.\n * const myEither = Either.try(() => Math.random() > 0.5 ? 'random success' : throw 'random failure');\n *\n * // you can also return Either.Failure or Either.Success based on a function logic\n * const myFunction = Math.random() > 0.5 ? Either.Success('random success') : Either.Failure('random failure');\n *\n * // you could access the actual value like this\n * myEither.value; // => 'random success' or 'random failure'\n *\n * // you can also inspect it by\n * myEither.inspect(); // => \"Success('random success')\" or Failure('random failure')\n *\n * // Either.of and Either.Success both represent success states\n * Either.of('some value').inspect() === Either.Success('some value').inspect(); // => true\n *\n * // you can check if the value is Failure\n * myEither.isFailure(); // => true or false\n * Either.of('abc').isFailure(); // => false\n * Either.Success('anything').isFailure(); // => false\n * Either.Failure('anything').isFailure(); // => true\n * Either.try(() => {throw 'error'}).isFailure(); // => true\n *\n * // you can check if the value is Success\n * myEither.isSuccess(); // => true or false\n * Either.of('abc').isSuccess(); // => true\n * Either.Success('anything').isSuccess(); // => true\n * Either.Failure('anything').isSuccess(); // => false\n * Either.try(() => {throw 'error'}).isSuccess(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Failure)\n * myEither.map(value => upperCaseOf(value));\n * myEither.inspect(); // => \"Success('RANDOM SUCCESS')\" or \"Failure('random failure')\"\n *\n * // as a monad Either can be safely flat mapped with other Eithers (flatMap doesn't execute over Failure)\n * Either.of(3).flatMap(a => Either.of(a + 2)).inspect(); // => 'Success(5)'\n * Either.Failure(3).flatMap(a => Either.of(null)).inspect(); // => 'Failure(3)'\n * Either.of(3).flatMap(a => a + 2); // => 5\n *\n * // as an applicative functor you can apply Eithers to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Either.of(2))(Either.of(3)); // => Success(5)\n * Either.of(1).map(add).ap(Either.of(2)).inspect(); // => 'Success(3)'\n * Either.Failure(1).map(add).ap(Either.of(2)).inspect(); // => 'Failure(1)'\n * Either.of(add).ap(Either.of(1)).ap(Either.of(2)).inspect(); // => 'Success(3)'\n */\nexport const Either = {\n  of: value => Success(value),\n  Success: value => Success(value),\n  Failure: value => Failure(value),\n  try: fn => {\n    try {\n      return Success(fn());\n    } catch(e) {\n      return Failure(e.message);\n    }\n  }\n};\n\nconst Failure = value => ({\n  value: value,\n  inspect: () => `Failure(${deepInspect(value)})`,\n  isFailure: () => true,\n  isSuccess: () => false,\n  map: () => Failure(value),\n  flatMap: () => Failure(value),\n  ap: () => Failure(value)\n});\n\nconst Success = value => ({\n  value: value,\n  inspect: () => `Success(${deepInspect(value)})`,\n  isFailure: () => false,\n  isSuccess: () => true,\n  map: fn => Either.of(fn(value)),\n  flatMap: fn => fn(value),\n  ap: f => f.map(value)\n});\n\n/**\n * either outputs result of a function onRight if input Either is Success or outputs result of a function onLeft if input Either is Failure.\n *\n * either can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner either :: (a -> b) -> (b -> c) -> Either\n *\n * @pure\n * @param {function} onFailure\n * @param {function} onSuccess\n * @param {Either} functorEither\n * @return {*}\n *\n * @example\n * import {either, Either} from '@7urtle/lambda';\n *\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')); // => 'success abc'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.Failure('failure')); // => 'error failure'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.try(() => throw 'failure')); // => 'error failure'\n *\n * // either can be called both as a curried unary function or as a standard ternary function\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')) === either(a => 'error ' + a, a => 'success ' + a, Either.of('abc'));\n */\nexport const either = nary(onFailure => onSuccess => functorEither =>\n  functorEither.isFailure()\n    ? onFailure(functorEither.value)\n    : onSuccess(functorEither.value));","import {deepInspect} from \"./utils\";\nimport {nary} from \"./arity\";\nimport {isFunction} from \"./conditional\";\n\n/**\n * AsyncEffect is a monad that allows you to safely work with asynchronous side effects in JavaScript.\n *\n * AsyncEffect expects as its input a function that takes two inputs of a reject function, and a resolve\n * function. Reject function is called on failure and resolve function is called on success. It is similar\n * to using JavaScript Promise and AsyncEffect can be directly created from a Promise turning it into a monad.\n *\n * AsyncEffect is evaluated lazily and nothing is executed until a trigger function is called.\n *\n * AsyncEffect can also be called Future monad in other libraries or languages.\n *\n * @example\n * import {AsyncEffect, log, upperCaseOf, liftA2, liftA3} from '@7urtle/lambda';\n *\n * // we create AsyncEffect that expects a number from 0 to 1\n * // and based on that, it resolve or rejects 10 milliseconds after it is triggered\n * const myAsyncEffect = AsyncEffect\n * .of(reject => resolve =>\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n *\n * // we could also create AsyncEffect from a JavaScript Promise\n * const myPromise = new Promise((resolve, reject) =>\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n * const promiseAsyncEffect = AsyncEffect.ofPromise(myPromise);\n *\n * // you can inspect AsyncEffect by\n * myAsyncEffect.inspect(); // => \"AsyncEffect(function...\n *\n * // when you are ready, you can call trigger to trigger the side effect\n * // nothing is executed until the trigger is called\n * myAsyncEffect\n * .trigger\n * (error => log(error))\n * (result => log(result));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // you can also turn AsyncEffect into a JavaScript Promise\n * myAsyncEffect\n * .promise()\n * .then(result => log(result), error => log(error));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // thrown exceptions lead AsyncEffect to reject\n * AsyncEffect\n * .of(() => {\n *     throw 'error';\n * })\n * .trigger(log)(log);\n * // => logs 'error'\n *\n * // as a functor the value inside is safely mappable\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\n * myAsyncEffect\n * .map(value => upperCaseOf(value))\n * .trigger(log)(log);\n * // => logs 'RANDOM SUCCESS' or 'random failure' depending on Math.random() value\n *\n * // as a monad AsyncEffect can be safely flat mapped with other AsyncEffects\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\n * AsyncEffect\n * .of(reject => resolve => resolve('7urtle'))\n * .flatMap(a => AsyncEffect.of(reject => resolve => resolve(a + 's')))\n * .trigger(log)(log);\n * // => logs '7urtles'\n *\n * // as an applicative functor you can apply AsyncEffects to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * const AS1 = AsyncEffect.of(reject => resolve => resolve(1));\n * const AS2 = AsyncEffect.of(reject => resolve => resolve(2));\n * liftA2(add)(AS1)(AS2); // => resolve(3)\n *\n * const ASFail = AsyncEffect.of(() => {throw 'error'});\n * liftA3(add)(ASFail)(AS1)(AS2); // => reject('error')\n *\n * // AsyncEffect.of as well as AsyncEffect.trigger accept both curried and binary functions\n * AsyncEffect.of((reject, resolve) => resolve('7urtle')).trigger(log, log); // logs '7urtle'\n *\n * // as an example you can use AsyncEffect to help you work with axios or fs\n *\n * // axios example\n * import axios from 'axios';\n * const getFromURL = url => AsyncEffect.ofPromise(axios.get(url));\n *\n * getFromURL('/my/ajax/url')\n * .trigger\n * (error => log(error))\n * (result => log(result.data));\n *\n * // reading file example\n * import fs from 'fs';\n * const readFile => input =>\n *     AsyncEffect\n *     .of(reject => resolve =>\n *         fs.readFile(input, (err, data) =>\n *             err ? reject(err) : resolve(data)\n *         )\n *     );\n *\n * readFile('./file.txt')\n * .trigger\n * (error => log(error))\n * (result => log(result));;\n */\nexport const AsyncEffect = {\n  of: trigger => getAsyncEffect(nary(reject => resolve => {\n    try {\n      const result = trigger(reject, resolve);\n      return isFunction(result) ? result(resolve) : result;\n    } catch(error) {\n      reject(error);\n    }\n  })),\n  ofPromise: promise => AsyncEffect.of(reject => resolve =>\n      promise.then(resolve).catch(reject)\n  )\n};\n\nconst getAsyncEffect = trigger => ({\n  trigger: trigger,\n  inspect: () => `AsyncEffect(${deepInspect(trigger)})`,\n  promise: () => new Promise((resolve, reject) => trigger(reject)(resolve)),\n  map: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(a => resolve(fn(a))))),\n  flatMap: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(x => fn(x).trigger(reject)(resolve)))),\n  ap: f => getAsyncEffect(trigger).flatMap(fn => f.map(fn))\n});","import {isTrue, passThrough, compose, upperCaseOf, identity} from \"@7urtle/lambda\";\n\n/**\n * createLogger accepts configuration as its input and outputs an object representing a logger with methods\n * log, debug, info, warn, and error. If no configuration is provided then a default is used.\n *\n * @HindleyMilner logger :: object -> object\n *\n * @pure\n * @param {object} configuration\n * @return {object}\n *\n * @example\n * import logger from '@7urtle/logger';\n *\n * const myDefaultLogger = logger();\n * myDefaultLogger.log('hello world'); // => 'hello world'\n * // returns 'hello world'\n * // but prints out '19/11/2020, 3:27:25 pm; LOG: hello world' using default decorator and console.log\n *\n * const myConfiguration = {\n *     levels: {\n *         debug: false, // ignore all debug calls\n *         info: false   // ignore all info calls\n *     },\n *     decorator: level => input => `${level}: ${input}`,\n *     library: {\n *         log: () => null,\n *         debug: () => null,\n *         info: () => null,\n *         warn: () => null,\n *         error: () => null\n *     }\n * };\n *\n * const myCustomLogger = logger(myConfiguration);\n * logger.debug('hello world'); // => 'hello world'\n * // returns 'hello world' but because debug level is false, the library function is not called\n *\n * logger.log('hello world'); // => 'hello world'\n * // returns 'hello world' and library function is called defined as () => null\n */\nconst logger = (configuration = undefined) => getLogger({\n  levels: {\n    log: true,\n    debug: true,\n    info: true,\n    warn: true,\n    error: true,\n    ...(configuration && configuration.levels)\n  },\n  library: configuration && configuration.library || console,\n  decorator: configuration && configuration && configuration.decorator || defaultDecorator\n});\n\n/**\n * defaultDecorator is the default decorator used by the default configuration of createLogger. It expects as inputs\n * string of a level and a message. It outputs a string in format 'TIME; LEVEL: message', for\n * example: '19/11/2020, 3:27:25 pm; DEBUG: hello world'.\n *\n * This function is not pure because it depends on the value of Date object.\n *\n * @HindleyMilner defaultDecorator :: string -> string -> string\n *\n * @param {string} level\n * @param {string} message\n * @return {string}\n *\n * @example\n * import {defaultDecorator} '@7urtle/logger';\n *\n * defaultDecorator('apocalyptic')('server meltdown');\n * // => '29/08/1997, 11:12:22 pm; APOCALYPTIC: server meltdown'\n */\nconst defaultDecorator = level => message =>\n  new Date().toLocaleString() + '; ' + upperCaseOf(level) + ': ' + message;\n\n/**\n * getLogger accepts configuration and returns an object with logging methods with a behavior depending on the\n * configuration passed to the function log. Provided methods are log, debug, info, warn, and error.\n *\n * @HindleyMilner getLogger :: object -> object\n *\n * @pure\n * @param {object} configuration\n * @return {object}\n *\n * @example\n * import {getLogger} '@7urtle/logger';\n *\n * const myConfiguration = {\n *     levels: {\n *         log: true,\n *         debug: false,\n *         info: true,\n *         warn: true,\n *         error: true\n *     },\n *     decorator: level => input => `${level}: ${input}`,\n *     library: console.log\n * };\n *\n * const myLogger = getLogger(myConfiguration);\n *\n * myLogger.error('hello error'); // => 'hello error'\n * // returns 'hello error'\n * // but prints out 'error: hello error' using provided decorator and console.log\n *\n * myLogger.debug('turned off'); // => 'turned off'\n * // returns 'turned off'\n * // but doesnt call the library function because debug level is false in the configuration\n */\nconst getLogger = configuration => ({\n  log: log(configuration)('log'),\n  debug: log(configuration)('debug'),\n  info: log(configuration)('info'),\n  warn: log(configuration)('warn'),\n  error: log(configuration)('error')\n});\n\n/**\n * log accepts configuration and current level as an input. If current level is set as true in provided configuration\n * it returns a logging function. The logging function uses configuration decorator to decorate logging message and\n * passes to the appropriate library logging function, however, it returns its original message as its output. If the\n * current level is set as false in the provided configuration then the log function simply returns identity which outputs\n * its input without any change and without calling the configuration library logging function.\n *\n * @HindleyMilner getLogger :: object -> object\n *\n * @pure\n * @param {object} configuration\n * @param {string} level\n * @return {object}\n *\n * @example\n * import {log} '@7urtle/logger';\n *\n * const myConfiguration = {\n *     levels: {\n *         log: true,\n *         debug: false,\n *         info: true,\n *         warn: true,\n *         error: true\n *     },\n *     decorator: level => input => `${level}: ${input}`,\n *     library: console.log\n * };\n *\n * log(myConfiguration)('info')('message'); // => 'message'\n * // returns 'message'\n * // but prints out 'info: message' using provided decorator and console.log\n *\n * log(myConfiguration)('debug')('turned off'); // => 'turned off'\n * // returns 'turned off'\n * // but doesnt call the library function because debug level is false in the configuration\n */\nconst log = configuration => level =>\n  isTrue(configuration.levels[level])\n    ? passThrough(compose(configuration.library[level], configuration.decorator(level)))\n    : identity;\n\nexport default logger;\n\nexport {\n  defaultDecorator,\n  getLogger,\n  log\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"http\");;","import {AsyncEffect, Either, lowerCaseOf, isNothing, upperCaseOf} from \"@7urtle/lambda\";\nimport * as queryString from 'query-string';\n\n/**\n * parseJSON :: String -> Either\n *\n * parseJSON parses into String to JSON returning Either functor with the result\n */\nconst parseJSON = data => Either.try(() => JSON.parse(data));\n\n/**\n * getRequestObject :: object -> object\n *\n * getRequestObject extracts request data from input requestHook and outputs request object.\n */\nconst getRequestObject = configuration => requestHook => ({\n  configuration: configuration,\n  path: requestHook.url,\n  method: lowerCaseOf(requestHook.method),\n  data: isNothing(requestHook.data)\n    ? undefined\n    : (json =>\n        json.isFailure()\n          ? queryString.parse(requestHook.data)\n          : json.value\n    )(parseJSON(requestHook.data))\n});\n\n/**\n * logRequest :: object -> object -> object\n *\n * logRequest uses logger for debug log of request method and url.\n */\nconst logRequest = request => {\n  request.configuration.logger.debug(`Request received for ${upperCaseOf(request.method)} ${request.path}.`);\n  return request;\n};\n\n\n/**\n * RequestEffect :: object -> object -> AsyncEffect\n *\n * RequestEffect(object)(object).trigger(d -> e, f -> g) for GET requestHook returns correct request object.\n * RequestEffect(object)(object).trigger(d -> e, f -> g) for POST requestHook returns correct request object including data.\n */\nconst RequestEffect = requestHook => configuration =>\n  AsyncEffect.of(\n    async (reject, resolve) => {\n      requestHook.data = '';\n      requestHook.on('data',\n        input => {\n          configuration.logger.debug('Receiving data on request.');\n          requestHook.data += input;\n        }\n        // consider using stream-meter https://stackoverflow.com/questions/4295782/how-to-process-post-data-in-node-js\n      );\n      requestHook.on('end',\n        () => resolve(requestHook)\n      );\n    }\n  )\n  .map(getRequestObject(configuration))\n  .map(logRequest);\n\nexport default RequestEffect;\n\nexport {\n  getRequestObject,\n  logRequest,\n  parseJSON\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");;","import {passThrough, isJust, Either, either, identity, AsyncEffect} from \"@7urtle/lambda\";\nimport fs from \"fs\";\n\n/**\n * getHeaders :: object -> object\n *\n * getHeaders creates headers object out of response object.\n * getHeaders uses text/plain content type if content-type is not specified.\n */\nconst getHeaders = response => (headers => ({\n  ...headers,\n  'content-type': response.contentType || 'text/plain',\n  'content-length': response.contentLength || Buffer.byteLength(response.content || '')\n}))((({configuration, data, contentType, contentLength, content, file, method, path, status, ...headers}) => headers)(response)); // remove unwanted properties\n\n/**\n * sendHead :: object -> object -> Either\n */\nconst sendHead = responseHook => response =>\n  either\n  (error => passThrough(response => response.configuration.logger.error(error))(response))\n  (identity)\n  (Either.try(() =>\n    passThrough(\n      response => responseHook.writeHead(response.status || 200, getHeaders(response))\n    )(response)\n  ));\n\n/**\n * sendContent :: object -> object -> Either\n *\n * sendContent triggers responseHook.end side effect and outputs Success(responseHook) on success.\n * sendContent triggers responseHook.end side effect and outputs Failure(string) on fail.\n */\nconst sendContent = responseHook => response =>\n  Either.try(() =>\n    passThrough(\n      response => isJust(response.content) ? responseHook.end(response.content) : responseHook.end()\n    )(response)\n  );\n\n/**\n * streamFile :: object -> object -> (a -> b, c -> d) -> {}\n *\n * streamFile triggers read data stream side effect streaming response.file and outputs Success(responseHook) on success.\n * streamFile triggers read data stream side effect streaming response.file and outputs Failure(string) on fail.\n */\nconst streamFile = responseHook => response => (reject, resolve) =>\n  fs.existsSync(response.file)\n    ?\n    fs\n    .createReadStream(response.file)\n    .on('error', reject)\n    .on('close', () => resolve(response))\n    .pipe(responseHook)\n    : reject(new Error('Response file does not exist.'));\n\n/**\n * sendOrStream :: object -> object -> object\n *\n * sendOrStream outputs Either calling streamFile or sendContent depending on whether response.file is just.\n */\nconst sendOrStream = responseHook => response =>\n  AsyncEffect.of(\n    async (reject, resolve) =>\n      isJust(response.file)\n        ? streamFile(responseHook)(response)(reject, resolve)\n        : either(reject)(resolve)(sendContent(responseHook)(response))\n  );\n\n/**\n * ResponseEffect :: object -> object -> AsyncEffect\n */\nconst ResponseEffect = responseHook => response => {\n  sendHead(responseHook)(response);\n  return sendOrStream(responseHook)(response);\n};\n\nexport default ResponseEffect;\n\nexport {\n  getHeaders,\n  sendHead,\n  sendContent,\n  streamFile,\n  sendOrStream\n};","import {endsWith, startsWith, substr, lengthOf, isEqual, Maybe, maybe, isFunction, passThrough} from '@7urtle/lambda';\n\n/**\n * checkRoute :: string -> object -> boolean\n *\n * checkRoute outputs true if inputs path and route.path match.\n * checkRoute supports /* routes.\n */\nconst checkRoute = path => route =>\n  endsWith('/*')(route.path)\n    ? startsWith(substr(lengthOf(route.path) - 2)(0)(route.path))(path)\n    : isEqual(route.path)(path);\n\n/**\n * MaybeRoute :: object -> Maybe\n *\n * MaybeRoute outputs Maybe of route found in input request or Maybe of Nothing if route is not found.\n */\nconst MaybeRoute = request =>\n  Maybe.of(request.configuration.routes.find(checkRoute(request.path)));\n\n/**\n * emptyContent :: AsyncEffect -> AsyncEffect\n *\n * emptyContent maps AsyncEffect evaluating contentLength and making file and content values empty.\n */\nconst emptyContent = ApiEffect =>\n  ApiEffect\n  .map(result => ({\n    ...result,\n    contentLength: result.contentLength || Buffer.byteLength(result.content),\n    file: '',\n    content: ''\n  }));\n\n/**\n * rawGetApiEffect :: object -> AsyncEffect\n *\n * rawGetApiEffect outputs AsyncEffect with the response to a request based on a route.\n * rawGetApiEffect if head is not api call it outputs AsyncEffect of api call for get with empty file and content result if get is defined.\n * rawGetApiEffect if head is not api call it outputs AsyncEffect of api call for any with empty file and content result if get is not defined.\n * rawGetApiEffect outputs AsyncEffect of api 404 error for head call if head, get and any are not found.\n * rawGetApiEffect outputs AsyncEffect of api 404 error call if route is not found.\n * rawGetApiEffect outputs AsyncEffect of api any call if requested method call is not found.\n * rawGetApiEffect outputs AsyncEffect of 404 api call if both requested method call and any call are not found.\n */\nconst rawGetApiEffect = request =>\n  maybe\n  (request.configuration.apiError.any({...request, status: 404}))\n  (route =>\n    isFunction(route.api[request.method]) // is there api call for the request method?\n      ? route.api[request.method](request) // call api for the request method\n      : isEqual(request.method)('head') // is request method HEAD?\n      ? isFunction(route.api.get) // can I use get instead of head\n        ? emptyContent(route.api.get(request)) // use get instead of head\n        : isFunction(route.api.any) // can I used any instead of head\n          ? emptyContent(route.api.any(request)) // use any instead of head\n          : emptyContent(request.configuration.apiError.any({...request, status: 404})) // call api for 404 error\n      : isFunction(route.api.any) // is there api any function?\n        ? route.api.any(request) // call api any function\n        : request.configuration.apiError.any({...request, status: 404}) // call api for 404 error\n  )\n  (MaybeRoute(request));\n// TODO: add some automated response for OPTIONS request method\n\n/**\n * memory :: object\n *\n * memory used for default function memoization\n */\nlet memory = {};\n\n/**\n * memoizedGetApiEffect :: object -> object -> AsyncEffect\n */\nconst memoizedGetApiEffect = memory => request =>\n  (key =>\n    key in memory\n      ? memory[key]\n      : (passThrough(result => memory[key] = result))\n        (rawGetApiEffect(request))\n  )\n  (request.path + ' ' + request.method);\n\n/**\n * getApiEffect :: object -> AsyncEffect\n *\n * getApiEffect is memoized version of rawGetApiEffect\n */\nconst getApiEffect = memoizedGetApiEffect(memory);\n\nexport default {getApiEffect};\n\nexport {\n  checkRoute,\n  MaybeRoute,\n  emptyContent,\n  rawGetApiEffect,\n  memoizedGetApiEffect,\n  memory\n};","import http from \"http\";\nimport {compose, isEqual, isNumber, identity} from \"@7urtle/lambda\";\nimport RequestEffect from \"./RequestEffect\";\nimport ResponseEffect from \"./ResponseEffect\";\nimport Router from \"./Router\";\n\n/**\n * getServer :: object -> http.Server\n *\n * getServer uses configuration object to start server with listeners for request and error\n */\nconst getServer = configuration =>\n  http\n  .createServer()\n  .on('request', configuration.listeners.request)\n  .on('error', configuration.listeners.error)\n  .listen(configuration.options.port, configuration.listeners.listening);\n\n/**\n * addListeners :: object -> object\n *\n * addListeners adds listener functions for request, error, and listening to provided configuration if not predefined.\n */\nconst addListeners = configuration => ({\n  listeners: {\n    request: requestListener(configuration),\n    error: errorListener(configuration),\n    listening: listeningListener(configuration),\n    ...configuration.listeners\n  },\n  ...configuration\n});\n\n/**\n * listeningListener :: object -> () -> string\n *\n * listeningListener uses logger provided in input configuration object to log listening event.\n */\nconst listeningListener = configuration => () =>\n  configuration.logger.info(`Server is listening on port ${configuration.options.port}.`);\n\n/**\n * errorListener :: object -> object|string -> string\n *\n * errorListener uses logger provided in input configuration object to log error listening event error object.\n */\nconst errorListener = configuration => error =>\n  isEqual(error.code)('EADDRINUSE')\n    ? configuration.logger.error(`Port ${configuration.options.port} is already in use. Server cannot start.`)\n    : configuration.logger.error(error.message || error.code || error);\n\n/**\n * respondToError :: object -> object -> number|any -> {}\n *\n * respondToError responds using ResponseHook to errors rejected during request processing.\n */\nconst respondToError = responseHook => configuration => error =>\n  isNumber(error)\n    ? configuration.logger.error(`Server request API processing failed with status: ${error}.`)\n    && respondWithApiError(configuration)(responseHook)(error)\n    : configuration.logger.error(`Server request processing failed with error: '${error}'.`)\n    && respondWithApiError(configuration)(responseHook)(500);\n\n/**\n * respondWithApiError :: object -> object -> number -> {}\n *\n * respondWithApiError triggers AsyncEffect of apiError for input status and logs potential error.\n */\nconst respondWithApiError = configuration => responseHook => status =>\n  configuration.apiError.any({\n    configuration: configuration,\n    status: status\n  })\n  .flatMap(ResponseEffect(responseHook))\n  .trigger(\n    error => configuration.logger.error(error),\n    identity\n  );\n\n/**\n * requestListener :: object -> (object, object) -> {}\n *\n * requestListener uses configuration to resolve request from requestHook by sending response using responseHook.\n */\nconst requestListener = configuration => (requestHook, responseHook) =>\n  RequestEffect(requestHook)(configuration)\n  .flatMap(Router.getApiEffect)\n  .flatMap(ResponseEffect(responseHook))\n  .trigger(\n    respondToError(responseHook)(configuration),\n    identity\n  );\n\n/**\n * create :: object -> http.Server\n *\n * create adds listeners to configuration and creates a listening http.Server.\n */\nconst create = compose(getServer, addListeners);\n\nexport default {create};\n\nexport {\n  getServer,\n  addListeners,\n  listeningListener,\n  errorListener,\n  respondToError,\n  respondWithApiError,\n  requestListener\n};","import http from 'http';\nimport {AsyncEffect, isNumber, isUndefined, compose} from '@7urtle/lambda';\n\nconst addStatusContent = request =>\n  isNumber(request.status)\n    ? ({\n      ...request,\n      content: http.STATUS_CODES[request.status]\n    })\n    : request.configuration.logger.warn('HTTP status was not provided or it is not a number. 500 status used.')\n    && ({\n      ...request,\n      status: 500,\n      content: 'Internal Server Error'\n    });\n\nconst undefinedContentTo500 = request =>\n  isUndefined(request.content)\n    ? request.configuration.logger.warn('Unknown HTTP status code number provided to apiError. 500 status used.')\n    && ({\n      ...request,\n      status: 500,\n      content: 'Internal Server Error'\n    })\n    : request;\n\nconst createApiEffect = request =>\n  AsyncEffect.of(\n    async (_, resolve) => resolve({\n      ...request,\n      contentType: 'text/plain'\n    })\n  );\n\nconst any = compose(createApiEffect, undefinedContentTo500, addStatusContent);\n\nexport default {any};","import {AsyncEffect, isEqual} from '@7urtle/lambda';\nimport fs from \"fs\";\nimport mimeTypes from \"mime-types\";\n\n/**\n * apiFile :: string -> object\n *\n * apiFile outputs api object with get call that outputs response object based on input file path.\n */\nconst apiFile = path => ({\n  get: request =>\n    AsyncEffect.of(\n      async (reject, resolve) =>\n        fs.existsSync(path)\n          ? resolve({\n            ...request,\n            status: 200,\n            file: isEqual('get')(request.method) ? path : '',\n            contentType: mimeTypes.lookup(path) || 'application/octet-stream',\n            contentLength: fs.statSync(path).size\n          })\n          : reject(404)\n    )\n});\n\nexport default apiFile;","import createLogger from \"@7urtle/logger\";\nimport Server from \"./Server\";\nimport apiError from \"./apis/apiError\";\nimport apiFile from \"./apis/apiFile\";\n\nconst defaultConfiguration = {\n  options: {\n    port: process.env.port || 3000\n  },\n  logger: createLogger(),\n  routes: [],\n  apiError: apiError,\n};\n\nconst start = configuration =>\n  Server.create({\n    ...defaultConfiguration,\n    ...configuration\n  });\n\nexport default {start};\n\nexport {apiFile};"],"sourceRoot":""}