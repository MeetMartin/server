{"version":3,"file":"server.min.cjs","mappings":"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","sources":["webpack://server/webpack/universalModuleDefinition","webpack://server/./node_modules/mime-db/index.js","webpack://server/./node_modules/mime-types/index.js","webpack://server/external node-commonjs \"path\"","webpack://server/./node_modules/@babel/runtime/helpers/regeneratorRuntime.js","webpack://server/./node_modules/@babel/runtime/helpers/typeof.js","webpack://server/./node_modules/@babel/runtime/regenerator/index.js","webpack://server/webpack/bootstrap","webpack://server/webpack/runtime/define property getters","webpack://server/webpack/runtime/hasOwnProperty shorthand","webpack://server/webpack/runtime/make namespace object","webpack://server/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://server/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://server/./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack://server/./node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack://server/./node_modules/@7urtle/lambda/src/arity.js","webpack://server/./node_modules/@7urtle/lambda/src/conditional.js","webpack://server/./node_modules/@7urtle/lambda/src/list.js","webpack://server/./node_modules/@7urtle/lambda/src/core.js","webpack://server/./node_modules/@7urtle/lambda/src/utils.js","webpack://server/./node_modules/@7urtle/lambda/src/string.js","webpack://server/./node_modules/@7urtle/logger/src/index.js","webpack://server/external node-commonjs \"http\"","webpack://server/./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack://server/./node_modules/@7urtle/lambda/src/Either.js","webpack://server/./node_modules/@7urtle/lambda/src/AsyncEffect.js","webpack://server/./node_modules/decode-uri-component/index.js","webpack://server/./node_modules/split-on-first/index.js","webpack://server/./node_modules/filter-obj/index.js","webpack://server/./node_modules/query-string/base.js","webpack://server/./node_modules/query-string/index.js","webpack://server/./src/RequestEffect.js","webpack://server/external node-commonjs \"fs\"","webpack://server/./src/ResponseEffect.js","webpack://server/./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","webpack://server/./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","webpack://server/./node_modules/@7urtle/lambda/src/Maybe.js","webpack://server/./src/Router.js","webpack://server/./src/Server.js","webpack://server/./src/apis/apiError.js","webpack://server/./src/apis/apiFile.js","webpack://server/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"server\"] = factory();\n\telse\n\t\troot[\"server\"] = factory();\n})(this, () => {\nreturn ","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","module.exports = require(\"path\");","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return e;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var t,\n    e = {},\n    r = Object.prototype,\n    n = r.hasOwnProperty,\n    o = Object.defineProperty || function (t, e, r) {\n      t[e] = r.value;\n    },\n    i = \"function\" == typeof Symbol ? Symbol : {},\n    a = i.iterator || \"@@iterator\",\n    c = i.asyncIterator || \"@@asyncIterator\",\n    u = i.toStringTag || \"@@toStringTag\";\n  function define(t, e, r) {\n    return Object.defineProperty(t, e, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), t[e];\n  }\n  try {\n    define({}, \"\");\n  } catch (t) {\n    define = function define(t, e, r) {\n      return t[e] = r;\n    };\n  }\n  function wrap(t, e, r, n) {\n    var i = e && e.prototype instanceof Generator ? e : Generator,\n      a = Object.create(i.prototype),\n      c = new Context(n || []);\n    return o(a, \"_invoke\", {\n      value: makeInvokeMethod(t, r, c)\n    }), a;\n  }\n  function tryCatch(t, e, r) {\n    try {\n      return {\n        type: \"normal\",\n        arg: t.call(e, r)\n      };\n    } catch (t) {\n      return {\n        type: \"throw\",\n        arg: t\n      };\n    }\n  }\n  e.wrap = wrap;\n  var h = \"suspendedStart\",\n    l = \"suspendedYield\",\n    f = \"executing\",\n    s = \"completed\",\n    y = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var p = {};\n  define(p, a, function () {\n    return this;\n  });\n  var d = Object.getPrototypeOf,\n    v = d && d(d(values([])));\n  v && v !== r && n.call(v, a) && (p = v);\n  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n  function defineIteratorMethods(t) {\n    [\"next\", \"throw\", \"return\"].forEach(function (e) {\n      define(t, e, function (t) {\n        return this._invoke(e, t);\n      });\n    });\n  }\n  function AsyncIterator(t, e) {\n    function invoke(r, o, i, a) {\n      var c = tryCatch(t[r], t, o);\n      if (\"throw\" !== c.type) {\n        var u = c.arg,\n          h = u.value;\n        return h && \"object\" == _typeof(h) && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n          invoke(\"next\", t, i, a);\n        }, function (t) {\n          invoke(\"throw\", t, i, a);\n        }) : e.resolve(h).then(function (t) {\n          u.value = t, i(u);\n        }, function (t) {\n          return invoke(\"throw\", t, i, a);\n        });\n      }\n      a(c.arg);\n    }\n    var r;\n    o(this, \"_invoke\", {\n      value: function value(t, n) {\n        function callInvokeWithMethodAndArg() {\n          return new e(function (e, r) {\n            invoke(t, n, e, r);\n          });\n        }\n        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(e, r, n) {\n    var o = h;\n    return function (i, a) {\n      if (o === f) throw Error(\"Generator is already running\");\n      if (o === s) {\n        if (\"throw\" === i) throw a;\n        return {\n          value: t,\n          done: !0\n        };\n      }\n      for (n.method = i, n.arg = a;;) {\n        var c = n.delegate;\n        if (c) {\n          var u = maybeInvokeDelegate(c, n);\n          if (u) {\n            if (u === y) continue;\n            return u;\n          }\n        }\n        if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n          if (o === h) throw o = s, n.arg;\n          n.dispatchException(n.arg);\n        } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n        o = f;\n        var p = tryCatch(e, r, n);\n        if (\"normal\" === p.type) {\n          if (o = n.done ? s : l, p.arg === y) continue;\n          return {\n            value: p.arg,\n            done: n.done\n          };\n        }\n        \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(e, r) {\n    var n = r.method,\n      o = e.iterator[n];\n    if (o === t) return r.delegate = null, \"throw\" === n && e.iterator[\"return\"] && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n    var i = tryCatch(o, e.iterator, r.arg);\n    if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n    var a = i.arg;\n    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n  }\n  function pushTryEntry(t) {\n    var e = {\n      tryLoc: t[0]\n    };\n    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n  }\n  function resetTryEntry(t) {\n    var e = t.completion || {};\n    e.type = \"normal\", delete e.arg, t.completion = e;\n  }\n  function Context(t) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], t.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(e) {\n    if (e || \"\" === e) {\n      var r = e[a];\n      if (r) return r.call(e);\n      if (\"function\" == typeof e.next) return e;\n      if (!isNaN(e.length)) {\n        var o = -1,\n          i = function next() {\n            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n            return next.value = t, next.done = !0, next;\n          };\n        return i.next = i;\n      }\n    }\n    throw new TypeError(_typeof(e) + \" is not iterable\");\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), o(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n    var e = \"function\" == typeof t && t.constructor;\n    return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n  }, e.mark = function (t) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n  }, e.awrap = function (t) {\n    return {\n      __await: t\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n    return this;\n  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n    void 0 === i && (i = Promise);\n    var a = new AsyncIterator(wrap(t, r, n, o), i);\n    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n      return t.done ? t.value : a.next();\n    });\n  }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n    return this;\n  }), define(g, \"toString\", function () {\n    return \"[object Generator]\";\n  }), e.keys = function (t) {\n    var e = Object(t),\n      r = [];\n    for (var n in e) r.push(n);\n    return r.reverse(), function next() {\n      for (; r.length;) {\n        var t = r.pop();\n        if (t in e) return next.value = t, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, e.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(e) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var t = this.tryEntries[0].completion;\n      if (\"throw\" === t.type) throw t.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(e) {\n      if (this.done) throw e;\n      var r = this;\n      function handle(n, o) {\n        return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n      }\n      for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n        var i = this.tryEntries[o],\n          a = i.completion;\n        if (\"root\" === i.tryLoc) return handle(\"end\");\n        if (i.tryLoc <= this.prev) {\n          var c = n.call(i, \"catchLoc\"),\n            u = n.call(i, \"finallyLoc\");\n          if (c && u) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          } else if (c) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n          } else {\n            if (!u) throw Error(\"try statement without catch or finally\");\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(t, e) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var o = this.tryEntries[r];\n        if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n          var i = o;\n          break;\n        }\n      }\n      i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n      var a = i ? i.completion : {};\n      return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n    },\n    complete: function complete(t, e) {\n      if (\"throw\" === t.type) throw t.arg;\n      return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n    },\n    finish: function finish(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n      }\n    },\n    \"catch\": function _catch(t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.tryLoc === t) {\n          var n = r.completion;\n          if (\"throw\" === n.type) {\n            var o = n.arg;\n            resetTryEntry(r);\n          }\n          return o;\n        }\n      }\n      throw Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(e, r, n) {\n      return this.delegate = {\n        iterator: values(e),\n        resultName: r,\n        nextLoc: n\n      }, \"next\" === this.method && (this.arg = t), y;\n    }\n  }, e;\n}\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","// TODO(Babel 8): Remove this file.\n\nvar runtime = require(\"../helpers/regeneratorRuntime\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}","import _typeof from \"./typeof.js\";\nexport default function toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}","/**\n * nary curried function and allows it to be called both as curried and n-ary.\n *\n * @HindleyMilner nary :: (a -> b) -> a -> b\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {nary} from '@7urtle/lambda';\n *\n * const fn = nary(a => b => a + b);\n * fn('a')('b') === fn('a', 'b'); // => true\n */\nexport const nary = fn =>\n    (...args) => args.length === 0\n        ? fn()\n        : args.reduce(\n            (accumulator, current) => accumulator(current),\n            fn\n        );\n\n/**\n * curry takes n-ary function and allows it to be called both as curried and n-ary.\n *\n * @HindleyMilner curry :: (a -> b) -> a -> b\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {curry} from '@7urtle/lambda';\n *\n * const fn = curry((a, b) => a + b);\n * fn('a')('b') === fn('a', 'b'); // => true\n */\nexport const curry = fn =>\n    (...args) => args.length >= fn.length\n        ? fn(...args)\n        : (...args2) => curry(fn)(...args, ...args2);","import { typeOf, lengthOf, deepInspect } from \"./utils.js\";\nimport { everyOf, someOf } from './list.js';\nimport { nary } from \"./arity.js\";\n\n/**\n * and is a boolean-type function composition\n * where each boolean function is '&&'d together.\n * \n * The boolean functions may be entered in any order.\n * \n * and can be used together with or to encapsulate a predicate in a single function.\n * \n * @HindleyMilner and :: [(a -> boolean)] -> a -> boolean\n * \n * @pure\n * @param {function} predicates\n * @param {*} anything\n * @return {*}\n * \n * @example\n * import {and, isGreaterThan, isLessThan} from '@7urtle/lambda';\n * \n * const isEven = number => number % 2 === 0;\n * \n * const isSingleEvenDigit = and(isEven, isGreaterThan(-10), isLessThan(10));\n * isSingleEvenDigit(8)\n * // => true\n */\n export const and = (...predicates) => anything => everyOf(predicate => predicate(anything))(predicates);\n\n /**\n  * or is a boolean-type function composition\n  * where each boolean function is '||'d together.\n  * \n  * The boolean functions may be entered in any order.\n  * \n  * or can be used together with and to encapsulate a predicate in a single function.\n  * \n  * @HindleyMilner or :: [(a -> boolean)] -> a -> boolean\n  * \n  * @pure\n  * @param {function} predicates\n  * @param {*} anything\n  * @return {*}\n  * \n  * @example\n  * import {or} from '@7urtle/lambda';\n  * \n  * const isDivisibleBy = divisor => number => number % divisor === 0;\n  * const isFizzBuzzNumber = or(isDivisibleBy(3), isDivisibleBy(5));\n  * \n  * isFizzBuzzNumber(15)\n  * // => true\n  */\n export const or = (...predicates) => anything => someOf(predicate => predicate(anything))(predicates);\n\n/**\n * isEqual output is true if strict equality between a and b is true. isEqual output is always false for comparison\n * of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isEqual} from '@7urtle/lambda';\n *\n * isEqual('something')('something'); // => true\n * isEqual('something')('something else'); // => false\n * isEqual(['a'])(['a']); // => false\n * isEqual({a : 'something'})({a : 'something'}); // => false\n * isEqual([])([]); // => false\n * isEqual([])([]); // => false\n *\n * // isEqual can be called both as a curried unary function or as a standard binary function\n * isEqual('something')('something') === isEqual('something', 'something');\n */\nexport const isEqual = nary(a => b => a === b);\n\n/**\n * isNotEqual output is true if strict equality between a and b is false. isNotEqual output is always true for\n * comparison of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotEqual} from '@7urtle/lambda';\n *\n * isNotEqual('something')('something'); // => false\n * isNotEqual('something')('something else'); // => true\n * isNotEqual(['a'])(['a']); // => true\n * isNotEqual({a : 'something'})({a : 'something'}); // => true\n * isNotEqual([])([]); // => true\n * isNotEqual([])([]); // => true\n *\n * // isNotEqual can be called both as a curried unary function or as a standard binary function\n * isNotEqual('something')('something else') === isNotEqual('something', 'something else');\n */\nexport const isNotEqual = nary(a => b => a !== b);\n\n/**\n * isDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is true including arrays and objects.\n *\n * isDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isDeepEqual} from '@7urtle/lambda';\n *\n * isDeepEqual('something')('something'); // => true\n * isDeepEqual('something')('something else'); // => false\n * isDeepEqual(['a'])(['a']); // => true\n * isDeepEqual({a : 'something'})({a : 'something'}); // => true\n * isDeepEqual([])([]); // => true\n * isDeepEqual([])([]); // => true\n *\n * // isDeepEqual can be called both as a curried unary function or as a standard binary function\n * isDeepEqual('something')('something') === isDeepEqual('something', 'something');\n */\nexport const isDeepEqual = nary(a => b => isEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isNotDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is false including arrays and objects.\n *\n * isNotDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotDeepEqual} from '@7urtle/lambda';\n *\n * isNotDeepEqual('something')('something'); // => false\n * isNotDeepEqual('something')('something else'); // => true\n * isNotDeepEqual(['a', 'b'])(['a']); // => true\n * isNotDeepEqual({a : 'something', b: c => c})({a : 'something'}); // => true\n * isNotDeepEqual([])([]); // => false\n * isNotDeepEqual([])([]); // => false\n *\n * // isNotDeepEqual can be called both as a curried unary function or as a standard binary function\n * isNotDeepEqual('something')('something else') === isNotDeepEqual('something', 'something else');\n */\nexport const isNotDeepEqual = nary(a => b => isNotEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isTrue output is true if input is true.\n *\n * @HindleyMilner isTrue :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isTrue} from '@7urtle/lambda';\n *\n * isTrue(true); // => true\n * isTrue(false); // => false\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse output is true if input is false.\n *\n * @HindleyMilner isFalse :: a -> Boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isFalse} from '@7urtle/lambda';\n *\n * isFalse(true); // => false\n * isFalse(false); // => true\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan output is true if b is greater than a.\n *\n * isGreaterThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isGreaterThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isGreaterThan} from '@7urtle/lambda';\n *\n * isGreaterThan(1)(2); // => true\n * isGreaterThan(3)(2); // => false\n *\n * // isGreaterThan can be called both as a curried unary function or as a standard binary function\n * isGreaterThan(1)(2) === isGreaterThan(1, 2);\n */\nexport const isGreaterThan = nary(a => b => b > a);\n\n/**\n * isLessThan output is true if b is less than a.\n *\n * isLessThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isLessThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLessThan} from '@7urtle/lambda';\n *\n * isLessThan(1)(2); // => false\n * isLessThan(3)(2); // => true\n *\n * // isLessThan can be called both as a curried unary function or as a standard binary function\n * isLessThan(3)(2) === isLessThan(3, 2);\n */\nexport const isLessThan = nary(a => b => b < a);\n\n/**\n * isAtLeast output is true if b is greater or equal to a.\n *\n * isAtLeast can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtLeast :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtLeast} from '@7urtle/lambda';\n *\n * isAtLeast(1)(2); // => true\n * isAtLeast(2)(2); // => true\n * isAtLeast(3)(2); // => false\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtLeast(1)(2) === isAtLeast(1, 2);\n */\nexport const isAtLeast = nary(a => b => b >= a);\n\n/**\n * isAtMost output is true if b is less or equal to a.\n *\n * isAtMost can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtMost :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtMost} from '@7urtle/lambda';\n *\n * isAtMost(1)(2); // => false\n * isAtMost(2)(2); // => true\n * isAtMost(3)(2); // => true\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtMost(3)(2) === isAtMost(31, 2);\n */\nexport const isAtMost = nary(a => b => b <= a);\n\n/**\n * isBetween output is true if c is between a and b.\n *\n * isBetween can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner isBetween :: a -> b -> c -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {boolean}\n *\n * @example\n * import {isBetween} from '@7urtle/lambda';\n *\n * isBetween(1)(3)(2); // => true\n * isBetween(3)(1)(2); // => true\n * isBetween(1)(3)(3); // => false\n * isBetween(1)(3)(4); // => false\n *\n * // isBetween can be called both as a curried unary function or as a standard ternary function\n * isBetween(1)(3)(2) === isBetween(1, 3, 2);\n */\nexport const isBetween = nary(a => b => c =>\n    a > b\n    ? a > c && b < c\n    : a < c && b > c\n);\n\n/**\n * isInRange output is true if c is in range of a and b.\n *\n * isInRange can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner isInRange :: a -> b -> c -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {boolean}\n *\n * @example\n * import {isInRange} from '@7urtle/lambda';\n *\n * isInRange(1)(3)(2); // => true\n * isInRange(3)(1)(2); // => true\n * isInRange(1)(3)(3); // => true\n * isInRange(1)(3)(4); // => false\n *\n * // isInRange can be called both as a curried unary function or as a standard ternary function\n * isInRange(1)(3)(2) === isInRange(1, 3, 2);\n */\n export const isInRange = nary(a => b => c =>\n    a > b\n    ? a >= c && b <= c\n    : a <= c && b >= c\n);\n\n/**\n * isTypeOf output is true if b is a type of a.\n *\n * isTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isTypeOf} from '@7urtle/lambda';\n *\n * isTypeOf('number')(1); // => true\n * isTypeOf('string')(1); // => false\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * isTypeOf('number')(1) === isTypeOf('number', 1);\n */\nexport const isTypeOf = nary(a => b => isEqual(typeOf(b))(a));\n\n/**\n * isNotTypeOf output is true if b is not a type of a.\n *\n * isNotTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotTypeOf} from '@7urtle/lambda';\n *\n * isNotTypeOf('number')(1); // => false\n * isNotTypeOf('string')(1); // => true\n *\n * // isNotTypeOf can be called both as a curried unary function or as a standard binary function\n * isNotTypeOf('string')(1) === isNotTypeOf('string', 1);\n */\nexport const isNotTypeOf = nary(a => b => isNotEqual(typeOf(b))(a));\n\n/**\n * isString output is true if input is a string.\n *\n * @HindleyMilner isString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isString} from '@7urtle/lambda';\n *\n * isString('string'); // => true\n * isString(1); // => false\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isNotString output is true if input is not a string.\n *\n * @HindleyMilner isNotString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotString} from '@7urtle/lambda';\n *\n * isNotString('string'); // => false\n * isNotString(1); // => true\n */\nexport const isNotString = isNotTypeOf('string');\n\n/**\n * isBoolean output is true if input is a boolean.\n *\n * @HindleyMilner isBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isBoolean} from '@7urtle/lambda';\n *\n * isBoolean(false); // => true\n * isBoolean(1); // => false\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNotBoolean output is true if input is not a boolean.\n *\n * @HindleyMilner isNotBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotBoolean} from '@7urtle/lambda';\n *\n * isNotBoolean(false); // => false\n * isNotBoolean(1); // => true\n */\nexport const isNotBoolean = isNotTypeOf('boolean');\n\n/**\n * isNull output is true if input is a null.\n *\n * @HindleyMilner isNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNull} from '@7urtle/lambda';\n *\n * isNull(null); // => true\n * isNull(1); // => false\n */\nexport const isNull = isEqual(null);\n\n/**\n * isNotNull output is true if input is not a null.\n *\n * @HindleyMilner isNotNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNull} from '@7urtle/lambda';\n *\n * isNotNull(null); // => false\n * isNotNull(1); // => true\n */\nexport const isNotNull = isNotEqual(null);\n\n/**\n * isUndefined output is true if input is an undefined.\n *\n * @HindleyMilner isUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isUndefined} from '@7urtle/lambda';\n *\n * isUndefined(undefined); // => true\n * isUndefined(1); // => false\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNotUndefined output is true if input is not an undefined.\n *\n * @HindleyMilner isNotUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotUndefined} from '@7urtle/lambda';\n *\n * isNotUndefined(undefined); // => false\n * isNotUndefined(1); // => true\n */\nexport const isNotUndefined = isNotTypeOf('undefined');\n\n/**\n * isNumber output is true if input is a number.\n *\n * @HindleyMilner isNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNumber} from '@7urtle/lambda';\n *\n * isNumber(1); // => true\n * isNumber('string'); // => false\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isNotNumber output is true if input is not a number.\n *\n * @HindleyMilner isNotNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNumber} from '@7urtle/lambda';\n *\n * isNotNumber(1); // => false\n * isNotNumber('string'); // => true\n */\nexport const isNotNumber = isNotTypeOf('number');\n\n/**\n * isObject output is true if b is an object, array, or null.\n *\n * @HindleyMilner isObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isObject} from '@7urtle/lambda';\n *\n * isObject({}); // => true\n * isObject([]); // => true\n * isObject(null); // => true\n * isObject(1); // => false\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isNotObject output is true if input is not an object, array, or null.\n *\n * @HindleyMilner isNotObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotObject} from '@7urtle/lambda';\n *\n * isNotObject({}); // => false\n * isNotObject([]); // => false\n * isNotObject(null); // => false\n * isNotObject(1); // => true\n */\nexport const isNotObject = isNotTypeOf('object');\n\n/**\n * isArray output is true if input is an array.\n *\n * @HindleyMilner isArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isArray} from '@7urtle/lambda';\n *\n * isArray([]); // => true\n * isArray({}); // => false\n */\nexport const isArray = Array.isArray;\n\n/**\n * isNotArray output is true if input is not an array.\n *\n * @HindleyMilner isNotArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotArray} from '@7urtle/lambda';\n *\n * isNotArray([]); // => false\n * isNotArray({}); // => true\n */\nexport const isNotArray = a => !Array.isArray(a);\n\n/**\n * isFunction output is true if input is a function.\n *\n * @HindleyMilner isFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isFunction} from '@7urtle/lambda';\n *\n * isFunction(() => null); // => true\n * isFunction(1); // => false\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isNotFunction output is true if input is not a function.\n *\n * @HindleyMilner isNotFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotFunction} from '@7urtle/lambda';\n *\n * isNotFunction(() => null); // => false\n * isNotFunction(1); // => true\n */\nexport const isNotFunction = isNotTypeOf('function');\n\n/**\n * isLength output is true if b is a length of a.\n *\n * @HindleyMilner isLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLength} from '@7urtle/lambda';\n *\n * isLength(3)('abc'); // => true\n * isLength(3)([1,2,3]); // => true\n * isLength(3)('abc'); // => false\n */\nexport const isLength = nary(a => b => isEqual(lengthOf(b))(a));\n\n/**\n * isNotLength output is true if b is not a length of a.\n * \n * The function can be called both as a unary isNotLength(a)(b) and binary isNotLength(a, b).\n *\n * @HindleyMilner isNotLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isNotLength} from '@7urtle/lambda';\n *\n * isNotLength(3)('abc'); // => false\n * isNotLength(3)([1,2,3]); // => false\n * isNotLength(3)('abce'); // => true\n * \n * isNotLength(3)('abcd') === isNotLength(3, 'abcd'); // => true\n */\nexport const isNotLength = nary(a => b => !isLength(a)(b));\n\n/**\n * isElement output is true if input is an HTML or SVG Element. Otherwise it is false.\n *\n * @HindleyMilner isElement :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isElement} from '@7urtle/lambda';\n *\n * isElement(document.createElement('span')); // => true\n */\nexport const isElement = anything =>\n    (typeof Element !== 'undefined' && anything instanceof Element) ||\n    (typeof HTMLDocument !== 'undefined' && anything instanceof HTMLDocument);\n\n/**\n * isNotElement output is true if input is not an HTML or SVG Element. Otherwise it is false.\n *\n * @HindleyMilner isNotElement :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isNotElement} from '@7urtle/lambda';\n *\n * isNotElement(document.createElement('span')); // => false\n */\nexport const isNotElement = anything => !isElement(anything);\n\n/**\n * isEmpty output is true if input is an empty string, array, or object. Otherwise it is false.\n *\n * @HindleyMilner isEmpty :: (string|array|Element) -> boolean\n *\n * @pure\n * @param {string|array|object} anything\n * @return {boolean}\n *\n * @example\n * import {isEmpty} from '@7urtle/lambda';\n *\n * isEmpty(''); // => true\n * isEmpty([]); // => true\n * isEmpty({}); // => true\n * isEmpty('abc'); // => false\n * isEmpty(document.getElementByID('image')); // => false\n */\nexport const isEmpty = anything =>\n    isLength(0)(anything) ||\n    isNotElement(anything) &&\n    (isObject(anything) ? isLength(0)(Object.getOwnPropertyNames(anything)) : false);\n\n/**\n * isNotEmpty output is false if input is an empty string, array, or object. Otherwise it is true.\n *\n * @HindleyMilner isNotEmpty :: (string|array|Element) -> boolean\n *\n * @pure\n * @param {string|array|object} anything\n * @return {boolean}\n *\n * @example\n * import {isNotEmpty} from '@7urtle/lambda';\n *\n * isNotEmpty(''); // => false\n * isNotEmpty([]); // => false\n * isNotEmpty('abc'); // => true\n * isNotEmpty({}); => true\n * isNotEmpty(document.getElementByID('image')); // => true\n */\nexport const isNotEmpty = anything => !isEmpty(anything);\n\n/**\n * isZero output is true if input is 0.\n *\n * @HindleyMilner isZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => true\n * isZero(1); // => false\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero output is true if input is not 0.\n *\n * @HindleyMilner isNotZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => false\n * isZero(1); // => true\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing returns true if input is null, undefined or empty string or empty array or empty object or the monad Nothing.\n *\n * @HindleyMilner isNothing :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import { isNothing, Maybe, Just, Nothing } from '@7urtle/lambda';\n *\n * isNothing(null); // => true\n * isNothing(undefined); // => true\n * isNothing(''); // => true\n * isNothing([]); // => true\n * isNothing({}); // => true\n * isNothing(Maybe.of('')); // => true\n * isNothing(Nothing); // => true\n * isNothing('7urtle'); // => false\n * isNothing(Maybe.of('7urtle')); // => false\n * isNothing(Just('7urtle')); // => false\n */\nexport const isNothing = anything =>\n    anything && anything.isNothing\n    ? anything.isNothing()\n    : isNull(anything) || isUndefined(anything) || isEmpty(anything);\n\n/**\n * isJust returns true if input is not null, undefined or empty string or empty array or empty object.\n *\n * @HindleyMilner isJust :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import { isJust, Maybe, Just, Nothing } from '@7urtle/lambda';\n *\n * isJust(null); // => false\n * isJust(undefined); // => false\n * isJust(''); // => false\n * isJust([]); // => false\n * isJust({}); // => false\n * isJust(Nothing); // => false\n * isJust('7urtle'); // => true\n * isJust(Maybe.of('7urtle')); // => true\n * isJust(Just('7urtle')); // => true\n */\nexport const isJust = anything =>\n    !isNothing(anything);\n\n/**\n * when tests anything argument by passing it to predicate function. If the predicate function is true, when\n * will return the result of whenTrueFn function which receivs the same anything argument. If the predicate\n * is false, then the anything argument is returned unchanged.\n * \n * The function can be called both as a unary when(predicate)(whenTrueFn)(anything) and ternary when(predicate, whenTrueFn, anything).\n *\n * @HindleyMilner when :: (a -> Boolean) -> (a -> a) -> a -> a\n *\n * @pure\n * @param {function} predicate\n * @param {function} whenTrueFn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {when} from '@7urtle/lambda';\n *\n * const predicate = a => a > 1;\n * const whenTrueFn = a => a * 2;\n * \n * when(predicate)(whenTrueFn)(2); // => 4\n * when(predicate)(whenTrueFn)(1); // => 1\n * \n * when(predicate)(whenTrueFn)(2) === when(predicate, whenTrueFn, 2); // => true\n */\nexport const when = nary(predicate => whenTrueFn => anything =>\n    predicate(anything)\n    ? whenTrueFn(anything)\n    : anything\n);\n\n/**\n * unless tests anything argument by passing it to predicate function. If the predicate function is false, unless\n * will return the result of whenFalseFn function which receivs the same anything argument. If the predicate\n * is true, then the anything argument is returned unchanged.\n * \n * The function can be called both as a unary unless(predicate)(whenFalseFn)(anything) and ternary unless(predicate, whenFalseFn, anything).\n *\n * @HindleyMilner unless :: (a -> Boolean) -> (a -> a) -> a -> a\n *\n * @pure\n * @param {function} predicate\n * @param {function} whenFalseFn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {unless} from '@7urtle/lambda';\n *\n * const predicate = a => a > 1;\n * const whenFalseFn = a => a * 2;\n * \n * when(predicate)(whenFalseFn)(4); // => 4\n * when(predicate)(whenFalseFn)(1); // => 2\n * \n * when(predicate)(whenFalseFn)(1) === when(predicate, whenFalseFn, 1); // => true\n */\nexport const unless = nary(predicate => whenFalseFn => anything =>\n    predicate(anything)\n    ? anything\n    : whenFalseFn(anything)\n);\n\n/**\n * ifElse tests anything argument by passing it to predicate function. If the predicate function is true, ifElse\n * will return the result of whenTrueFn function which receivs the same anything argument. If the predicate\n * is false, then the anything argument is passed to the whenFalseFn function.\n * \n * The function can be called both as a unary ifElse(predicate)(whenTrueFn)(whenFalseFn)(anything) and quaternary\n * ifElse(predicate, whenTrueFn, whenFalseFn, anything).\n *\n * @HindleyMilner ifElse :: (a -> Boolean) -> (a -> a) -> (a -> a) a -> a\n *\n * @pure\n * @param {function} predicate\n * @param {function} whenTrueFn\n * @param {function} whenFalseFn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {ifElse} from '@7urtle/lambda';\n *\n * const predicate = a => a > 1;\n * const whenTrueFn = a => a / 2;\n * const whenFalseFn = a => a * 2;\n * \n * ifElse(predicate)(whenTrueFn)(whenFalseFn)(4); // => 2\n * ifElse(predicate)(whenTrueFn)(whenFalseFn)(1); // => 2\n * \n * ifElse(predicate)(whenTrueFn)(whenFalseFn)(1) === ifElse(predicate, whenTrueFn, whenFalseFn, 1); // => true\n */\n export const ifElse = nary(predicate => whenTrueFn => whenFalseFn => anything =>\n    predicate(anything)\n    ? whenTrueFn(anything)\n    : whenFalseFn(anything)\n);","import {lengthOf, minusOneToUndefined} from './utils.js';\nimport {nary} from \"./arity.js\";\nimport {upperCaseOf} from \"./string.js\";\n\n/**\n * reduce executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduce executes functions in reverse order to reduceRight.\n *\n * reduce can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduce} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduce('start')(reducer)(list); // => startabc\n *\n * // reduce can be called both as a curried unary function or as a standard ternary function\n * reduce('start')(reducer)(list) === reduce('start', reducer, list);\n */\nexport const reduce = nary(initial => reducer => list => list.reduce(reducer, initial));\n\n/**\n * reduceRight executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduceRight executes functions in reverse order to reduce.\n *\n * reduceRight can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduceRight} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduceRight('start')(reducer)(list); // => startcba\n *\n * // reduceRight can be called both as a curried unary function or as a standard ternary function\n * reduceRight('start')(reducer)(list) === reduceRight('start', reducer, list);\n */\nexport const reduceRight = nary(initial => reducer => list => list.reduceRight(reducer, initial));\n\n/**\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n *\n * If you need to both filter and map over an array, consider using the filterMap function.\n *\n * filter can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner filter :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filter} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * filter(a => a > 1)(list); // => [2, 3]\n *\n * // filter can be called both as a curried unary function or as a standard binary function\n * filter(a => a > 1)(list) === filter(a => a > 1, list);\n */\nexport const filter = nary(checker => list => list.filter(checker));\n\n/**\n * filterMap executes mapper function over filtered input array or monad and outputs the resulting array or monad.\n *\n * Only one pass through the array is executed unlike the use of map(mapper)(filter(checker)(list)).\n *\n * filterMap can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner filterMap :: (a -> boolean) -> (a -> b) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {function} mapper\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filterMap} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n * const mapper = a => a + 1;\n * const checker = a => a > 1;\n *\n * filterMap(checker)(mapper)(list);  // => [3, 4]\n * filterMap(a => a > 1)(a => a + 1)([0, 1, 2, 3]); // => [3, 4]\n *\n * const mapOverLargerThanOne = filterMap(checker);\n * mapOverLargerThanOne(mapper)(list); // => [3, 4]\n *\n * // filterMap can be called both as a curried unary function or as a standard ternary function\n * filterMap(a => a > 1)(a => a + 1)(list) === filterMap(a => a > 1, a => a + 1, list);\n */\nexport const filterMap = nary(checker => mapper => list =>\n    reduce([])((acc, current) => checker(current) ? acc.push(mapper(current)) && acc : acc)(list));\n\n/**\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n *\n * find can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner find :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {find} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * find(a => a > 1)(list); // => 2\n * find(a => a > 3)(list); // => undefined\n *\n * // find can be called both as a curried unary function or as a standard binary function\n * find(a => a > 1)(list) === find(a => a > 1, list);\n */\nexport const find = nary(checker => list => list.find(checker));\n\n/**\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n *\n * findIndex can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {findIndex} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * findIndex(a => a > 2)(list); // => 1\n * findIndex(a => a > 4)(list); // => undefined\n *\n * // findIndex can be called both as a curried unary function or as a standard binary function\n * findIndex(a => a > 1)(list) === findIndex(a => a > 1, list);\n */\nexport const findIndex = nary(checker => list => minusOneToUndefined(list.findIndex(checker)));\n\n/**\n * join outputs a string created by joining input array members with input separator.\n *\n * join can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner join :: string -> [a] -> string\n *\n * @pure\n * @param {string} separator\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {join} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * join('')(list); // => '234'\n * join(' and ')(list); // => '2 and 3 and 4'\n * join()(list); // => '2,3,4'\n *\n * // join can be called both as a curried unary function or as a standard binary function\n * join('')(list) === join('', list);\n */\nexport const join = nary(separator => list => list.join(separator));\n\n/**\n * keysOf outputs array of string keys of input array or object.\n *\n * @HindleyMilner keysOf :: object -> [string]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {keysOf} from '@7urtle/lambda';\n *\n * keysOf([2, 3, 4]); // => ['0', '1', '2']\n * keysOf({1: 2, 2: 3}); // => ['1', '2']\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n *\n * @HindleyMilner entriesOf :: object -> [[string, a]]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {entriesOf} from '@7urtle/lambda';\n *\n * entriesOf([2, 3, 4]); // => [['0', 2], ['1', 3], ['2', 4]]\n * entriesOf({1: 2, 2: 3}); // => [['1', 2],['2', 3]]\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf outputs true if every element of input array passes input checker function as true.\n *\n * everyOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {everyOf} from '@7urtle/lambda';\n *\n * everyOf(a => a > 1)([2, 3, 4]); // => true\n * everyOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // everyOf can be called both as a curried unary function or as a standard binary function\n * everyOf(a => a > 1)([2, 3, 4]) === everyOf(a => a > 1, [2, 3, 4]);\n */\nexport const everyOf = nary(checker => list => list.every(checker));\n\n/**\n * slice outputs selected array elements as an array based on input range. First argument end\n * represents the ending index (not length) and start represents the starting index in the input\n * array list.\n *\n * slice can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner slice :: number -> number -> [a] -> [a]\n *\n * @pure\n * @param {number} end\n * @param {number} start\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {slice} from '@7urtle/lambda';\n *\n * slice(2)(1)([1, 2, 3, 4, 5]); // => [2]\n * slice(2)(0)([1, 2, 3, 4, 5]); // => [1, 2]\n * slice(8)(7)([1, 2, 3, 4, 5]); // => []\n *\n * // slice can be called both as a curried unary function or as a standard ternary function\n * slice(2)(1)([1, 2, 3, 4, 5]) === slice(2, 1, [1, 2, 3, 4, 5]);\n */\nexport const slice = nary(end => start => list => list.slice(start, end));\n\n/**\n * some outputs true if any element of input array passes input checker function as true.\n *\n * some can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner some :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {some} from '@7urtle/lambda';\n *\n * someOf(a => a > 1)([2, 3, 4]); // => true\n * someOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // some can be called both as a curried unary function or as a standard binary function\n * someOf(a => a > 1)([2, 3, 4]) === someOf(a => a > 1, [2, 3, 4]);\n */\nexport const someOf = nary(checker => list => list.some(checker));\n\n/**\n * sort outputs an array sorted based on input compare function.\n *\n * sort can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner sort :: (a -> number) -> [a] -> [a]\n *\n * @pure\n * @param {function} compare\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sort} from '@7urtle/lambda';\n *\n * sort((a, b) => a < b ? -1 : a > b ? 1 : 0)(['a', 'd', 'c', 'd']); // => ['a', 'c', 'd', 'd']\n * sort((a, b) => a - b)([5, 3, 6]); // => [3, 5, 6]\n *\n * // sort can be called both as a curried unary function or as a standard binary function\n * sort((a, b) => a - b)([5, 3, 6]) === sort((a, b) => a - b, [5, 3, 6]);\n */\nexport const sort = nary(compare => list => [...list].sort(compare));\n\n/**\n * sortAlphabetically outputs an array sorted alphabetically from a to z.\n *\n * @HindleyMilner sortAlphabetically :: [string] -> [string]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortAlphabetically} from '@7urtle/lambda';\n *\n * sortAlphabetically(['petra', 'Martin', 'Petra']); // => ['Martin', 'petra', 'Petra']\n */\nexport const sortAlphabetically = sort((a, b) => (a => b => a < b ? -1 : a > b ? 1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\n\n/**\n * sortAlphabeticallyZA outputs an array sorted alphabetically from z to a.\n *\n * @HindleyMilner sortAlphabeticallyZA :: [string] -> [string]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortAlphabeticallyZA} from '@7urtle/lambda';\n *\n * sortAlphabeticallyZA(['petra', 'Martin', 'Petra']); // => ['petra', 'Petra', 'Martin']\n */\nexport const sortAlphabeticallyZA = sort((a, b) => (a => b => a < b ? 1 : a > b ? -1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\n\n/**\n * sortNumerically outputs an array sorted numerically from 1 to 2.\n *\n * @HindleyMilner sortNumerically :: [number] -> [number]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortNumerically} from '@7urtle/lambda';\n *\n * sortNumerically([3, 4, 1, 3]); // => [1, 3, 3, 4]\n */\nexport const sortNumerically = sort((a, b) => a - b);\n\n/**\n * sortNumerically21 outputs an array sorted numerically from 2 to 1.\n *\n * @HindleyMilner sortNumerically21 :: [number] -> [number]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortNumerically21} from '@7urtle/lambda';\n *\n * sortNumerically21([3, 4, 1, 3]); // => [4, 3, 3, 1]\n */\nexport const sortNumerically21 = sort((a, b) => b - a);\n\n/**\n * headOf outputs the first item (head) from the input array.\n *\n * @HindleyMilner headOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {headOf} from '@7urtle/lambda';\n *\n * headOf([3, 4, 1, 8]); // => 3\n * headOf([8]); // => 8\n * headOf([]); // => undefined\n */\nexport const headOf = list => list[0];\n\n/**\n * tailOf outputs the the input array without its first item.\n *\n * @HindleyMilner tailOf :: [a] -> []\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {tailOf} from '@7urtle/lambda';\n *\n * tailOf([3, 4, 1, 8]); // => [4, 1, 8]\n * tailOf([8]); // => []\n * tailOf([]); // => []\n */\nexport const tailOf = list => list.slice(1);\n\n/**\n * initOf outputs the the input array without its last item.\n *\n * @HindleyMilner initOf :: [a] -> []\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {initOf} from '@7urtle/lambda';\n *\n * initOf([3, 4, 1, 8]); // => [3, 4, 1]\n * initOf([8]); // => []\n * initOf([]); // => []\n */\nexport const initOf = list => slice(lengthOf(list) -1)(0)(list);\n\n/**\n * lastOf outputs the last item from the input array.\n *\n * @HindleyMilner lastOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {lastOf} from '@7urtle/lambda';\n *\n * lastOf([3, 4, 1, 8]); // => 8\n * lastOf([3]); // => 3\n * lastOf([]); // => undefined\n */\nexport const lastOf = list => list[lengthOf(list) -1];\n\n/**\n * groupBy outputs an objects with groups produced by an input function over input list.\n *\n * groupBy can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner groupBy :: (a -> b) -> [a] -> {b: a}\n *\n * @pure\n * @param {function} fn\n * @param {array} list\n * @return {object}\n *\n * @example\n * import {groupBy} from '@7urtle/lambda';\n *\n * groupBy(a => a.length)(['one', 'two', 'three']);\n * // => {\"3\": [\"one\", \"two\"], \"5\": [\"three\"]}\n *\n * groupBy(a => a % 2)([1, 2, 3]);\n * // =>  {\"0\": [2], \"1\": [1, 3]}\n *\n * // groupBy can be called both as a curried unary function or as a standard binary function\n * groupBy(a => a.length)(['one', 'two', 'three']) === groupBy(a => a.length, ['one', 'two', 'three'])\n */\nexport const groupBy = nary(fn => list =>\n    reduce\n    ({})\n    ((acc, current) =>\n        (acc[fn(current)] = acc[fn(current)] || []).push(current) && acc\n    )\n    (list));\n\n/**\n * randomOf outputs a random item from the input array.\n *\n * @HindleyMilner randomOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {randomOf} from '@7urtle/lambda';\n *\n * randomOf([3, 4, 1, 8]); // => 8\n * randomOf([3]); // => 3\n * randomOf([]); // => undefined\n */\nexport const randomOf = list => list[Math.floor(Math.random() * lengthOf(list))];","import { reduce, reduceRight } from './list.js';\nimport { isString, isArray, isObject } from './conditional.js';\nimport { minusOneToUndefined, passThrough } from './utils.js';\nimport { nary } from \"./arity.js\";\n\n/**\n * identity is a function that simply passes its input to its output without changing it.\n *\n * @HindleyMilner identity :: a -> a\n *\n * @pure\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {identity} from '@7urtle/lambda';\n *\n * identity('anything');\n * // => anything\n */\nexport const identity = anything => anything;\n\n/**\n * compose is a right-to-left function composition\n * where each function receives input and hands over its output to the next function.\n *\n * compose executes functions in reverse order to pipe.\n *\n * compose(f,g)(x) is equivalent to f(g(x)).\n *\n * @HindleyMilner compose :: [(a -> b)] -> a -> b\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {compose} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = value => compose(addA, addB)(value);\n *\n * addAB('Order: ');\n * // => Order: BA\n */\nexport const compose = (...fns) => anything => reduceRight(anything)((v, f) => f(v))(fns);\n\n/**\n * pipe output is a left-to-right function composition\n * where each function receives input and hands over its output to the next function.\n *\n * pipe executes functions in reverse order to compose.\n *\n * pipe(f,g)(x) is equivalent to g(f(x)).\n *\n * @HindleyMilner pipe :: [(a -> b)] -> a -> b\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {pipe} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = value => pipe(addA, addB)(value);\n *\n * addAB('Order: ');\n * // => Order: AB\n */\nexport const pipe = (...fns) => anything => reduce(anything)((v, f) => f(v))(fns);\n\n/**\n * map executes mapper function over input. If the input is array or monad, their map functions\n * are executed. If the input is anything else the mapper function is executed with the input\n * as its argument.\n *\n * In case of monads, you should use map when you want to work with functors using functions\n * and functional composition rather than calling Functor.map.\n *\n * If you need to both filter and map over an array, consider using the filterMap function.\n *\n * map can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner map :: (a -> b) -> a -> b\n *\n * @param {function} mapper\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {map, Maybe, upperCaseOf} from '@7urtle/lambda';\n *\n * const mapper = a => a + 'm';\n * const list = ['a', 'b', 'c'];\n *\n * // the function mapper is applied to each member of the array\n * map(mapper)(list); // => ['am', 'bm', 'cm']\n *\n * // the function upperCaseOf is applied to the value of the functor\n * map(upperCaseOf)(Maybe.of('something')); // => Just('SOMETHING')\n * \n * // the function upperCaseOf is applied to the input string\n * map(upperCaseOf)('turtle'); // => 'TURTLE'\n *\n * // use of map equals the use of map on the functor\n * map(upperCaseOf)(Maybe.of('something')).value === Maybe.of('something').map(upperCaseOf).value;\n *\n * // map can be called both as a curried unary function or as a standard binary function\n * map(upperCaseOf)(Maybe.of('something')).value === map(upperCaseOf, Maybe.of('something')).value;\n */\nexport const map = nary(mapper => anything =>\n    anything && anything.map\n    ? anything.map(mapper)\n    : mapper(anything)\n);\n\n/**\n * flatMap maps function over inputted functor outputting resulting flattened functor.\n *\n * You should use flatMap when you want to work with functors using functions\n * and functional composition rather than calling flatMaps.\n *\n * The function can be called both as a unary flatMap(fn)(functor) and binary flatMap(fn, functor).\n *\n * @HindleyMilner flatMap :: (a -> Functor) -> Functor -> Functor\n *\n * @param {function} fn\n * @param {functor} functor\n * @return {functor}\n *\n * @example\n * import {flatMap, map, Maybe} from '@7urtle/lambda';\n *\n * const maybePlus2 = number => Maybe.of(number + 2);\n *\n * // the function maybePlus2 is applied to the value of the functor\n * flatMap(maybePlus2)(Maybe.of(3)); // => Just(5)\n * map(maybePlus2)(Maybe.of(3)); // => Just(Just(5))\n *\n * // use of flatMap equals the use of flatMap on the functor\n * flatMap(maybePlus2)(Maybe.of(3)).value === Maybe.of(3).flatMap(maybePlus2).value;\n *\n * // flatMap can be called both as a curried unary function or as a standard binary function\n * flatMap(maybePlus2)(Maybe.of(3)).value === flatMap(maybePlus2, Maybe.of(3)).value;\n */\nexport const flatMap = nary(fn => functor => functor.flatMap(fn));\n\n/**\n * liftA2 provides point-free way of writing calls over applicative functors and functions expecting 2 inputs. It\n * applies input function over both functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA2(fn)(functor)(functor) and ternary liftA2(fn, functor, functor).\n *\n * @HindleyMilner liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @return {functor}\n *\n * @example\n * import {liftA2, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => a + b;\n *\n * // function add which expects two inputs is applied to the values of two applicative functors Maybe\n * // the result is a Maybe functor with the internal value 5\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA2(add)(Maybe.of(1))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA2 can be called both as a curried unary function or as a standard ternary function\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)).value === liftA2(add, Maybe.of(2), Maybe.of(3)).value;\n */\nexport const liftA2 = nary(fn => ap1 => ap2 => ap1.map(fn).ap(ap2));\n\n/**\n * liftA3 provides point-free way of writing calls over applicative functors and functions expecting 3 inputs. It\n * applies input function over input functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA3(fn)(functor)(functor)(functor) and quaternary liftA2(fn, functor, functor, functor).\n *\n * @HindleyMilner liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @param {functor} ap3\n * @return {functor}\n *\n * @example\n * import {liftA3, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => c => a + b + c;\n *\n * // function add which expects three inputs is applied to the values of three applicative functors Maybe\n * // the result is a Maybe functor with the internal value 9\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)); // => Just(9)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA3(add)(Maybe.of(1))(Maybe.of(2))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA3 can be called both as a curried unary function or as a standard quaternary function\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)).value === liftA3(add, Maybe.of(2), Maybe.of(3), Maybe.of(4)).value;\n */\nexport const liftA3 = nary(fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3));\n\n/**\n * contact outputs concatenated inputs of strings, arrays and shallow objects or outputs undefined for other types.\n *\n * concat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner concat :: a -> a|boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {concat} from '@7urtle/lambda';\n *\n * concat('cd')('ab'); // => 'abcd'\n * concat([3, 4])([1,2]); // => [1, 2, 3, 4]\n * concat({here: {here: 'there'}})({hi: 'hello'}); // => {hi: 'hello', here: {here: 'there'}}\n * concat('cd')(1); // => undefined\n *\n * // concat can be called both as a curried unary function or as a standard binary function\n * concat('cd')('ab') === concat('cd', 'ab');\n */\nexport const concat = nary(a => b =>\n    isString(b) || isArray(b)\n        ? b.concat(a)\n        : isObject(b)\n            ? { ...b, ...a }\n            : undefined);\n\n/**\n * merge performs a deep merge on all input objects and arrays.\n *\n * @HindleyMilner merge :: [a] -> [b]\n *\n * @pure\n * @param {array|object} sources\n * @return {array|object}\n *\n * @example\n * import {merge} from '@7urtle/lambda';\n *\n * const obj1 = { a: 'a', c: ['a'] };\n * const obj2 = { b: a => a, d: ['a', 'b'] };\n * const obj3 = { a: 'c', c: ['c'] };\n *\n * merge(obj1, obj2, obj3));\n * // => {\"a\": \"c\", \"b\": a => a, \"c\": [\"a\", \"c\"], \"d\": [\"a\", \"b\"]}\n *\n * const list1 = ['a', 'b'];\n * const list2 = [1, 2];\n *\n * merge(list1,list2);\n * // => ['a', 'b', 1, 2]\n * \n * merge(list1, obj1)\n * // => {\"0\": \"a\", \"1\": \"b\", \"a\": \"a\", \"c\": [\"a\"]}\n */\nexport const merge = (...sources) =>\n    reduce\n        ([])\n        ((acc, current) =>\n            isArray(current)\n                ? [...acc, ...current]\n                : isObject(current)\n                    ? reduce\n                        (acc)\n                        ((a, c) =>\n                            isObject(current[c]) && c in acc\n                                ? { ...a, [c]: merge(acc[c], current[c]) }\n                                : { ...a, [c]: current[c] }\n                        )\n                        (Object.getOwnPropertyNames(current))\n                    : { ...acc, ...current }\n        )\n        (sources);\n\n/**\n * includes(a)(b) output is true if b includes a.\n *\n * includes can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner includes :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {includes} from '@7urtle/lambda';\n *\n * includes('rt')('7urtle'); // => true\n * includes(1)([1, 2, 3]) // => true\n * includes('turtle')([1, 2, 3]) // => false\n *\n * // includes can be called both as a curried unary function or as a standard binary function\n * includes('rt')('7urtle') === includes('rt', '7urtle');\n */\nexport const includes = nary(a => b => b.includes(a));\n\n/**\n * indexOf(a)(b) outputs position of input a within input b or undefined if it is not found.\n *\n * indexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner indexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {indexOf} from '@7urtle/lambda';\n *\n * indexOf('7')('7urtle'); // => 0\n * indexOf(7)('7urtle'); // => 0\n * indexOf(2)([1, 2, 3]); // => 1\n * indexOf(4)([1, 2, 3]); // => undefined\n *\n * // indexOf can be called both as a curried unary function or as a standard binary function\n * indexOf('7')('7urtle') === indexOf('7', '7urtle');\n */\nexport const indexOf = nary(a => b => minusOneToUndefined(b.indexOf(a)));\n\n/**\n * lastIndexOf(a)(b) outputs position of input a withing input b looking from the end or it retuns undefined if it is not found.\n *\n * lastIndexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner lastIndexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {lastIndexOf} from '@7urtle/lambda';\n *\n * lastIndexOf('urtle')('7urtle'); // => 1\n * lastIndexOf(2)([1, 2, 3, 2]); // => 3\n * lastIndexOf('8')('7urtle'); // => undefined\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard binary function\n * lastIndexOf('7')('7urtle') === lastIndexOf('7', '7urtle');\n */\nexport const lastIndexOf = nary(a => b => minusOneToUndefined(b.lastIndexOf(a)));\n\n/**\n * memoize uses input memory to save output of input function and then uses it to lookup the result on a repeated run. This\n * function is not pure because the input memory is modified in the process.\n *\n * The function can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner memoize :: object -> (a -> b) -> a -> b\n *\n * @param {object} memory\n * @param {function} fn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {memoize} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * let memory = {};\n *\n * memoize(memory)(addTwo)(1); // => 3\n * memoize(memory)(addTwo)(1); // => 3\n * memory[1]; // => 3\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard ternary function\n * memoize(memory)(addTwo)(1) === memoize(memory, addTwo, 1);\n */\nexport const memoize = nary(memory => fn => anything =>\n    anything in memory\n        ? memory[anything]\n        : passThrough(b => memory[anything] = b)(fn(anything))\n);\n\n/**\n * memo takes input function and returns it enhanced by memoization which ensures that each result is\n * always remembered internally and executed only once.\n *\n * @HindleyMilner memo :: (a -> b) -> (a -> b)\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {memo} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * const memoAddTwo = memo(addTwo);\n * const memoAddThree = memo(a => a + 3);\n *\n * memoAddTwo(1); // => 3\n * memoAddThree(1); // => 4\n *\n * let count = 0;\n * const increaseCount = () => ++count;\n *\n * increaseCount(); // 1\n * increaseCount(); // 2\n *\n * const memoIncreaseCount = memo(increaseCount);\n *\n * memoIncreaseCount(); // 3\n * memoIncreaseCount(); // 3\n * memoIncreaseCount(); // 3\n */\nexport const memo = fn => memoize({})(fn);\n\n/**\n * fail throws the input error. It is just a function wrapped around JavaScript throw.\n *\n * @HindleyMilner fail :: a -> b -> number\n *\n * @impure\n * @param {string|Error} error\n * @return {null}\n *\n * @example\n * import { fail } from '@7urtle/lambda';\n *\n * fail('I am an error.'); // => throws 'I am an error.'\n * fail(new Error('something happend :(')); // => throws Error('something happened :('))\n */\nexport const fail = error => { throw error; };","import { isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined } from \"./conditional.js\";\nimport {keysOf, join} from \"./list.js\";\nimport {map} from \"./core.js\";\nimport {nary} from \"./arity.js\";\n\n/**\n * typeOf outputs a type of its input.\n *\n * @HindleyMilner typeOf :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {typeOf} from '@7urtle/lambda';\n *\n * typeOf('7turtle'); // => 'string'\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf outputs the length of an input.\n *\n * @HindleyMilner lengthOf :: (string|array) -> number\n *\n * @pure\n * @param {string|array} a\n * @return {number}\n *\n * @example\n * import {lengthOf} from '@7urtle/lambda';\n *\n * lengthOf('7turtle'); // => 7\n * lengthOf([1,2,3]); // => 3\n * lengthOf({}); // => undefined\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough output is the same as input a. passThrough executes function passed as first argument.\n *\n * passThrough can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner passThrough :: function -> a -> a\n *\n * @pure\n * @param {function} fn\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {passThrough} from '@7urtle/lambda';\n *\n * passThrough(() => 'b')('a'); // => 'a'\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * passThrough(() => 'b')('a') === passThrough(() => 'b', 'a');\n */\nexport const passThrough = nary(fn => anything => {\n  fn(anything);\n  return anything;\n});\n\n/**\n * log output is the same as input and it logs the input value. log causes side effect of console.log.\n *\n * @HindleyMilner log :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * log('anything'); // => 'anything'\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy output is the same as input and it logs the deepInspect of the input. spy causes side effect of console.log.\n *\n * @HindleyMilner spy :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {spy} from '@7urtle/lambda';\n *\n * spy([1, 'a']); // => \"[1, 'a']\"\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n *\n * Because some functions return -1 as error state, this function is created to change it into a more consistent\n * undefined output.\n *\n * @HindleyMilner minusOneToUndefined :: a -> a|boolean\n *\n * @pure\n * @param {*} anything\n * @return {*|boolean}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * minusOneToUndefined(-1); // => undefined\n * minusOneToUndefined(0); // => 0\n * minusOneToUndefined('7urtle'); // => '7urtle'\n */\nexport const minusOneToUndefined = anything => isEqual(-1)(anything) ? undefined: anything;\n\n/**\n * inspectFunction outputs name of named function or its conversion to string.\n *\n * @HindleyMilner inspectFunction :: (a -> b) -> string\n *\n * @pure\n * @param {function} fn\n * @return {string}\n *\n * @example\n * import {inspectFunction} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectFunction(namedFunction); // => 'namedFunction'\n * inspectFunction(() => 'b');\n * // => `function () {\n * // =>     return 'b';\n * // => }`\n */\nexport const inspectFunction = fn => fn.name ? fn.name : String(fn);\n\n/**\n * inspectArray maps over input array [a] and outputs string representing it.\n *\n * @HindleyMilner inspectArray :: [a] -> string\n *\n * @pure\n * @param {array} a\n * @return {string}\n *\n * @example\n * import {inspectArray} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectArray([1, 'a']); // => \"[1, 'a']\"\n * inspectArray([namedFunction, 'a']); // => \"[namedFunction, 'a']\"\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString outputs string representing input.\n *\n * @HindleyMilner inspectString :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {inspectString} from '@7urtle/lambda';\n *\n * inspectString('my string'); // => \"'my string'\"\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject outputs string representing input.\n *\n * @HindleyMilner inspectObject :: a -> string\n *\n * @pure\n * @param {object} a\n * @return {string}\n *\n * @example\n * import {inspectObject} from '@7urtle/lambda';\n *\n * inspectObject({a: 'b'}); // => \"{a: 'b'}\"\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect runs recursively over input and outputs string representing the input.\n *\n * @HindleyMilner deepInspect :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {deepInspect} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * deepInspect({a: 'b'}); // => \"{a: 'b'}\"\n * deepInspect(namedFunction); // => 'namedFunction'\n * deepInspect([1, 'a']); // => \"[1, 'a']\"\n * deepInspect('my string'); // => \"'my string'\"\n * deepInspect(undefined); // => 'undefined'\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils.js';\nimport {nary} from \"./arity.js\";\n\n/**\n * trim output is a string without white characters around it.\n *\n * @HindleyMilner trim :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {trim} from '@7urtle/lambda';\n *\n * trim(' a \\n '); // => 'a'\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx outputs true if string b passes regular expression a.\n *\n * testRegEx can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner testRegEx :: regex -> string -> boolean\n *\n * @pure\n * @param {regex} regex\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {testRegEx} from '@7urtle/lambda';\n *\n * testRegEx(/[a-z]/)('7urtle'); // => true\n * testRegEx(/[0-9]/)('1'); // => true\n * testRegEx(/[0-9]/)('abc'); // => false\n *\n * // testRegEx can be called both as a curried unary function or as a standard binary function\n * testRegEx(/[a-z]/)('7urtle') === testRegEx(/[a-z]/, '7urtle');\n */\nexport const testRegEx = nary(regex => string => regex.test(string));\n\n/**\n * substr outputs substring based on provided string, start and limit.\n *\n * substr can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner substr :: number -> number -> string -> string\n *\n * @pure\n * @param {number} limit\n * @param {number} start\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {substr} from '@7urtle/lambda';\n *\n * substr(3)(1)('7urtle'); // => 'urt'\n * substr(1)(0)('7urtle'); // => '7'\n * substr(1)(-1)('7urtle'); // => 'e'\n *\n * // substr can be called both as a curried unary function or as a standard ternary function\n * substr(3)(1)('7urtle') === substr(3, 1, '7urtle');\n */\nexport const substr = nary(limit => start => string => string.substr(start, limit));\n\n/**\n * firstLetterOf outputs the first letter of a provided string.\n *\n * @HindleyMilner firstLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {firstLetterOf} from '@7urtle/lambda';\n *\n * firstLetterOf('7urtle'); // => '7'\n */\nexport const firstLetterOf = string => string.substr(0, 1);\n\n/**\n * lastLetterOf outputs the last letter of a provided string.\n *\n * @HindleyMilner lastLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lastLetterOf} from '@7urtle/lambda';\n *\n * lastLetterOf('7urtle'); // => 'e'\n */\nexport const lastLetterOf = string => string.substr(-1, 1);\n\n/**\n * startsWith outputs true if an input string starts with provided string.\n *\n * startsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner startsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {startsWith} from '@7urtle/lambda';\n *\n * startsWith('7')('7urtle'); // => true\n * startsWith('7urtl')('7urtle'); // => true\n * startsWith('8urtl')('7urtle'); // => false\n *\n * // startsWith can be called both as a curried unary function or as a standard binary function\n * startsWith('7')('7urtle') === startsWith('7', '7urtle');\n */\nexport const startsWith = nary(substring => string => string.startsWith(substring));\n\n/**\n * endsWith outputs true if an input string ends with provided string.\n *\n * endsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner endsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {endsWith} from '@7urtle/lambda';\n *\n * endsWith('7e')('7urtle'); // => true\n * endsWith('urtle')('7urtle'); // => true\n * endsWith('urtls')('7urtle'); // => false\n *\n * // endsWith can be called both as a curried unary function or as a standard binary function\n * endsWith('e')('7urtle') === endsWith('e', '7urtle');\n */\nexport const endsWith = nary(substring => string => string.endsWith(substring));\n\n/**\n * repeat outputs new string repeating input string inputted count of times.\n *\n * repeat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner repeat :: number -> string -> string\n *\n * @pure\n * @param {number} count\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {repeat} from '@7urtle/lambda';\n *\n * repeat(2)('7urtle'); // => '7urtle7urtle'\n * repeat(0)('7urtle'); // => ''\n *\n * // repeat can be called both as a curried unary function or as a standard binary function\n * repeat(2)('7urtle') === repeat(2, '7urtle');\n */\nexport const repeat = nary(count => string => string.repeat(count));\n\n/**\n * replace outputs new string replacing input substring with input replacement string in input string.\n *\n * replace can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner replace :: string -> string -> string -> string\n *\n * @pure\n * @param {string} replacement\n * @param {string} substring\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {replace} from '@7urtle/lambda';\n *\n * replace('8')('7')('7urtle'); // => '8urtle'\n * replace('7')('')('7urtle'); // => '77urtle'\n * replace('')('7')('7urtle'); // => 'urtle'\n *\n * // replace can be called both as a curried unary function or as a standard ternary function\n * replace('8')('7')('7urtle') === replace('8', '7', '7urtle');\n */\nexport const replace = nary(replacement => substring => string => string.replace(substring, replacement));\n\n/**\n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n *\n * search can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner search :: string/regex -> string -> number\n *\n * @pure\n * @param {string|regex} substring\n * @param {string} string\n * @return {number}\n *\n * @example\n * import {search} from '@7urtle/lambda';\n *\n * search('7')('7urtle'); 0\n * search('e')('7urtle'); // => 5\n * search('rt')('7urtle'); // => 2\n * search(/URT/i)('7urtle'); // => 1\n * search('8')('7urtle'); => undefined\n *\n * // search can be called both as a curried unary function or as a standard binary function\n * search('7')('7urtle') === search('7', '7urtle');\n */\nexport const search = nary(substring => string => minusOneToUndefined(string.search(substring)));\n\n/**\n * split outputs and array of an input string split by the input substring.\n *\n * split can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner split :: string -> string -> array\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {array}\n *\n * @example\n * import {split} from '@7urtle/lambda';\n *\n * split(' ')('7urtles are awesome'); // => ['7urtles', 'are', 'awesome']\n * split('/')('7urtles are awesome'); // => ['7urtles are awesome']\n *\n * // split can be called both as a curried unary function or as a standard binary function\n * split(' ')('7urtles are awesome') === split(' ', '7urtles are awesome');\n */\nexport const split = nary(substring => string => string.split(substring));\n\n/**\n * lowerCaseOf outputs the lower case version of input string.\n *\n * @HindleyMilner lowerCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lowerCaseOf} from '@7urtle/lambda';\n *\n * lowerCaseOf('PeTrA'); // => 'petra'\n * lowerCaseOf('PŘÍŠERNĚ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY'); // => 'příšerně žluťoučký kůň úpěl ďábelské ódy'\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf outputs the upper case version of input string.\n *\n * @HindleyMilner upperCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {upperCaseOf} from '@7urtle/lambda';\n *\n * upperCaseOf('PeTrA'); // => 'PETRA'\n * upperCaseOf('příšerně žluťoučký kůň úpěl ďábelské ódy'); // => 'PŘÍŠERNĚ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY'\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {isTrue, upperCaseOf, identity, lengthOf, isEqual, headOf, tailOf} from \"@7urtle/lambda\";\n\n/**\n * createLogger accepts configuration as its input and outputs an object representing a logger with methods\n * log, debug, info, warn, and error. If no configuration is provided then a default is used.\n *\n * @HindleyMilner logger :: object -> object\n *\n * @pure\n * @param {object} configuration\n * @return {object}\n *\n * @example\n * import logger from '@7urtle/logger';\n *\n * const myDefaultLogger = logger();\n * myDefaultLogger.log('hello world'); // => 'hello world'\n * // returns 'hello world'\n * // but prints out '19/11/2020, 3:27:25 pm; LOG: hello world' using default decorator and console.log\n *\n * const myConfiguration = {\n *     levels: {\n *         debug: false, // ignore all debug calls\n *         info: false   // ignore all info calls\n *     },\n *     decorator: level => input => `${level}: ${input}`,\n *     library: {\n *         log: () => null,\n *         debug: () => null,\n *         info: () => null,\n *         warn: () => null,\n *         error: () => null\n *     }\n * };\n *\n * const myCustomLogger = logger(myConfiguration);\n * logger.debug('hello world'); // => 'hello world'\n * // returns 'hello world' but because debug level is false, the library function is not called\n *\n * logger.log('hello world'); // => 'hello world'\n * // returns 'hello world' and library function is called defined as () => null\n */\nconst logger = (configuration = undefined) => getLogger({\n  levels: {\n    log: true,\n    debug: true,\n    info: true,\n    warn: true,\n    error: true,\n    ...(configuration && configuration.levels)\n  },\n  library: configuration && configuration.library || {\n    log: console.log,\n    debug: console.log,\n    info: console.log,\n    warn: console.warn,\n    error: console.error,\n  },\n  decorator: configuration && configuration && configuration.decorator || defaultDecorator\n});\n\n/**\n * defaultDecorator is the default decorator used by the default configuration of createLogger. It expects as inputs\n * string of a level and a message. It outputs a string in format 'TIME; LEVEL: message', for\n * example: '19/11/2020, 3:27:25 pm; DEBUG: hello world'.\n *\n * This function is not pure because it depends on the value of Date object.\n *\n * @HindleyMilner defaultDecorator :: string -> string -> string\n *\n * @param {string} level\n * @param {string} message\n * @return {string}\n *\n * @example\n * import {defaultDecorator} '@7urtle/logger';\n *\n * defaultDecorator('apocalyptic')('server meltdown');\n * // => '29/08/1997, 11:12:22 pm; APOCALYPTIC: server meltdown'\n */\nconst defaultDecorator = level => message =>\n  new Date().toLocaleString() + '; ' + upperCaseOf(level) + ': ' + message;\n\n/**\n * getLogger accepts configuration and returns an object with logging methods with a behavior depending on the\n * configuration passed to the function log. Provided methods are log, debug, info, warn, and error.\n *\n * @HindleyMilner getLogger :: object -> object\n *\n * @pure\n * @param {object} configuration\n * @return {object}\n *\n * @example\n * import {getLogger} '@7urtle/logger';\n *\n * const myConfiguration = {\n *     levels: {\n *         log: true,\n *         debug: false,\n *         info: true,\n *         warn: true,\n *         error: true\n *     },\n *     decorator: level => input => `${level}: ${input}`,\n *     library: console.log\n * };\n *\n * const myLogger = getLogger(myConfiguration);\n *\n * myLogger.error('hello error'); // => 'hello error'\n * // returns 'hello error'\n * // but prints out 'error: hello error' using provided decorator and console.log\n *\n * myLogger.debug('turned off'); // => 'turned off'\n * // returns 'turned off'\n * // but doesnt call the library function because debug level is false in the configuration\n */\nconst getLogger = configuration => ({\n  log: log(configuration)('log'),\n  debug: log(configuration)('debug'),\n  info: log(configuration)('info'),\n  warn: log(configuration)('warn'),\n  error: log(configuration)('error')\n});\n\n/**\n * log accepts configuration and current level as an input. If current level is set as true in provided configuration\n * it returns a logging function. The logging function uses configuration decorator to decorate logging message and\n * passes to the appropriate library logging function, however, it returns its original message as its output. If the\n * current level is set as false in the provided configuration then the log function simply returns identity which outputs\n * its input without any change and without calling the configuration library logging function.\n *\n * @HindleyMilner getLogger :: object -> object\n *\n * @pure\n * @param {object} configuration\n * @param {string} level\n * @return {object}\n *\n * @example\n * import {log} '@7urtle/logger';\n *\n * const myConfiguration = {\n *     levels: {\n *         log: true,\n *         debug: false,\n *         info: true,\n *         warn: true,\n *         error: true\n *     },\n *     decorator: level => input => `${level}: ${input}`,\n *     library: console.log\n * };\n *\n * log(myConfiguration)('info')('message'); // => 'message'\n * // returns 'message'\n * // but prints out 'info: message' using provided decorator and console.log\n *\n * log(myConfiguration)('debug')('turned off'); // => 'turned off'\n * // returns 'turned off'\n * // but doesnt call the library function because debug level is false in the configuration\n */\nconst log = configuration => level =>\n  isTrue(configuration.levels[level])\n    ? (...message) => {\n        configuration.library[level](configuration.decorator(level)(headOf(message)), ...tailOf(message));\n        return isEqual(1)(lengthOf(message)) ? message[0] : message;\n    }\n    : identity;\n\nexport {\n  defaultDecorator,\n  getLogger,\n  log\n};\n\nexport default logger;","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"http\");","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}","import { deepInspect } from './utils.js';\nimport { nary } from './arity.js';\nimport { reduce } from './list.js';\nimport { Maybe, Nothing } from './Maybe.js';\nimport { SyncEffect } from './SyncEffect.js';\nimport { AsyncEffect } from './AsyncEffect.js';\n\nexport const Failure = value => ({\n  value: value,\n  inspect: () => `Failure(${deepInspect(value)})`,\n  isFailure: () => true,\n  isSuccess: () => false,\n  map: () => Failure(value),\n  flatMap: () => Failure(value),\n  catchMap: fn => Failure(fn(value)),\n  bimap: nary(leftFn => _ => Failure(leftFn(value))),\n  ap: () => Failure(value),\n  orOf: a => Success(a),\n  orElse: fn => fn(),\n  orTry: fn => Either.try(fn)\n});\n\nexport const Success = value => ({\n  value: value,\n  inspect: () => `Success(${deepInspect(value)})`,\n  isFailure: () => false,\n  isSuccess: () => true,\n  map: fn => Success(fn(value)),\n  catchMap: () => Success(value),\n  bimap: nary(_ => rightFn => Success(rightFn(value))),\n  flatMap: fn => fn(value),\n  ap: m => m.map(value),\n  orOf: () => Success(value),\n  orElse: () => Success(value),\n  orTry: () => Success(value)\n});\n\n/**\n * Either is an excellent monad for handling error states and it is fairly similar to our monad Maybe. Either.Failure\n * represents an error state and Either.Success represents a success state.\n *\n * Either.of expects a value as its input. Either.of is the same as Either.Success. You can initiate Either\n * in its error state by Either.Failure.\n *\n * You can also initiate it using Either.try which expects a function as an input. It is Failure if an error\n * or exception is thrown. It is Success if there are no errors or exceptions.\n *\n * Either is called Either because it allows you to branch based on an error state. You want to use Either\n * for situations when you don't know whether there might be an error. It makes the very visible that an error\n * can occur and it forces the consumer to handle the situation.\n *\n * @example\n * import {either, Either, Success, Failure, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we randomly give Either a value or throw an error. Either.try() outputs an instance of Either.\n * const myEither = Either.try(() => Math.random() > 0.5 ? 'random success' : throw 'random failure');\n *\n * // you can also return Either.Failure or Either.Success based on a function logic\n * const myFunction = Math.random() > 0.5 ? Either.Success('random success') : Either.Failure('random failure');\n * \n * // Success and Failure can be called directly\n * Success('7urtle') === Either.Success('7urtle'); // => true\n * Success('7urtle') === Either.of('7urtle'); // => true\n * Failure('error') === Either.Failure('error'); // => true\n *\n * // you could access the actual value like this\n * myEither.value; // => 'random success' or 'random failure'\n *\n * // you can also inspect it by\n * myEither.inspect(); // => \"Success('random success')\" or Failure('random failure')\n *\n * // Either.of and Either.Success both represent success states\n * Either.of('some value').inspect() === Success('some value').inspect(); // => true\n *\n * // you can check if the value is Failure\n * myEither.isFailure(); // => true or false\n * Either.of('abc').isFailure(); // => false\n * Success('anything').isFailure(); // => false\n * Failure('anything').isFailure(); // => true\n * Either.try(() => {throw 'error'}).isFailure(); // => true\n *\n * // you can check if the value is Success\n * myEither.isSuccess(); // => true or false\n * Either.of('abc').isSuccess(); // => true\n * Success('anything').isSuccess(); // => true\n * Failure('anything').isSuccess(); // => false\n * Either.try(() => {throw 'error'}).isSuccess(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Failure)\n * myEither.map(value => upperCaseOf(value));\n * myEither.inspect(); // => \"Success('RANDOM SUCCESS')\" or \"Failure('random failure')\"\n *\n * // as a monad Either can be safely flat mapped with other Eithers (flatMap doesn't execute over Failure)\n * Either.of(3).flatMap(a => Either.of(a + 2)).inspect(); // => 'Success(5)'\n * Failure(3).flatMap(a => Either.of(null)).inspect(); // => 'Failure(3)'\n * Either.of(3).flatMap(a => a + 2); // => 5\n * \n * // you can use catchMap if you want to map over Failure\n * Failure('error').catchMap(a => a + 's'); // => Failure('errors')\n * Success('7urtle').catchMap(a => a + 's'); // => Success('7urtle') \n * \n * // you can use bimap to map over both Success and Failure with different functions\n * Failure('error').bimap(a + ' is left')(a => a + ' is right');  // => Failure('error is left')\n * Succcess('7urtle').bimap(a + ' is left')(a => a + ' is right'); // => Success('7urtle is right')\n * \n * // orOf(a) replaces Failure with Success\n * Failure('error').orOf('7urtles'); // => Success('7urtle')\n * Success('7urtle').orOf('tortoise'); // => Success('7urtle')\n * \n * // orElse(a -> Either) replaces Failure with the output of orElse function\n * Failure('error').orElse(() => Success('7urtle')); // => Success('7urtle')\n * Success('7urtle').orElse(() => Success('tortoise')); // => Success('7urtle')\n * \n * // orTry(a -> b) replaces original Fairlure with Either.try\n * Failure('error').orTry(() => { throw 'i am an error'; }); // => Failure('i am an error')\n * Failure('error').orTry(() => '7urtle'); // => Success('7urtle')\n * Success('7urtle').orTry(() => { throw 'i am an error'; }); // => Success('7urtle')\n *\n * // as an applicative functor you can apply Eithers to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Either.of(2))(Either.of(3)); // => Success(5)\n * Either.of(1).map(add).ap(Either.of(2)).inspect(); // => 'Success(3)'\n * Failure(1).map(add).ap(Either.of(2)).inspect(); // => 'Failure(1)'\n * Either.of(add).ap(Either.of(1)).ap(Either.of(2)).inspect(); // => 'Success(3)'\n */\nexport const Either = {\n  of: value => Success(value),\n  Success: value => Success(value),\n  Failure: value => Failure(value),\n  try: fn => {\n    try {\n      return Success(fn());\n    } catch(error) {\n      return Failure(error.message || error);\n    }\n  }\n};\n\n/**\n * either outputs result of a function onRight if input Either is Success or outputs result of a function onLeft if input Either is Failure.\n *\n * either can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner either :: (a -> b) -> (b -> c) -> Either\n *\n * @pure\n * @param {function} onFailure\n * @param {function} onSuccess\n * @param {Either} functorEither\n * @return {*}\n *\n * @example\n * import {either, Either} from '@7urtle/lambda';\n *\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')); // => 'success abc'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.Failure('failure')); // => 'error failure'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.try(() => throw 'failure')); // => 'error failure'\n *\n * // either can be called both as a curried unary function or as a standard ternary function\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')) === either(a => 'error ' + a, a => 'success ' + a, Either.of('abc'));\n */\nexport const either = nary(onFailure => onSuccess => functorEither =>\n  functorEither.isFailure()\n    ? onFailure(functorEither.value)\n    : onSuccess(functorEither.value)\n);\n\n/**\n * mergeEithers outputs Either of array with all Either values depending whether they are Success or Failure.\n *\n * @HindleyMilner mergeEithers :: ([Either]) -> Either\n *\n * @pure\n * @param {Either} eithers\n * @return {Either}\n *\n * @example\n * import { mergeEithers, Either } from '@7urtle/lambda';\n *\n * mergeEithers(Either.of('abc'), Either.of('def')); //  => Success(['abc', 'def'])\n * mergeEithers(Either.of('abc'), Either.Failure('def')); // => Failure(['def'])\n * mergeEithers(Either.Failure('abc'), Either.of('def')); // => Failure(['abc'])\n * mergeEithers(Either.Failure('abc'), Either.Failure('def')); // => Failure(['abc', 'def'])\n */\nexport const mergeEithers = (...eithers) =>\n  reduce\n  (Success([]))\n  ((accumulator, current) =>\n    current.isFailure()\n    ? accumulator.isFailure() // current Either is Failure\n      ? Failure([...accumulator.value, current.value]) // accumulator is Failure and current is Failure => update accumulator\n      : Failure([current.value]) // accumulator is Success and current is Failure => return first Failure\n    : accumulator.isFailure() // current Either is Success\n      ? accumulator // accumulator is Failure and current is Success => return accumulator\n      : Success([...accumulator.value, current.value]) // accumulator is Success and current is Success => update accumulator\n  )\n  (eithers);\n\n/**\n * validateEithers outputs Either of input value if all input functions returns Success or Failure\n * with array of error messages.\n *\n * @HindleyMilner validateEithers :: ([a -> b]) -> a -> Either\n *\n * @pure\n * @param {functions} fns\n * @param {*} input\n * @return {Either}\n *\n * @example\n * import { validateEithers, Either, isAtLeast, lengthOf } from '@7urtle/lambda';\n *\n * // mergeEithers is great to be used for validations\n * const isPasswordLongEnough = password =>\n *  isAtLeast(6)(lengthOf(password))\n *  ? Either.Success(password)\n *  : Either.Failure('Password must have more than 6 characters.');\n * \n * const isPasswordStrongEnough = password =>\n *  /[\\W]/.test(password)\n *  ? Either.Success(password)\n *  : Either.Failure('Password must contain special characters.');\n * \n * const validatePassword = validateEithers(isPasswordLongEnough, isPasswordStrongEnough);\n * \n * validatePassword('LongPa$$word'); // => Success('LongPa$$word')\n * validatePassword('Pa$$'); // => Failure(['Password must have more than 6 characters.'])\n * validatePassword('LongPassword'); // => Failure(['Password must contain special characters.'])\n * validatePassword('Pass'); // => Failure(['Password must have more than 6 characters.', 'Password must contain special characters.'])\n */\nexport const validateEithers = (...fns) => input =>\n  reduce\n  (Success(input))\n  ((accumulator, currentFn) =>\n    (currentResult =>\n      currentResult.isFailure()\n      ? accumulator.isFailure() // currentResult Either is Failure\n        ? Failure([...accumulator.value, currentResult.value]) // accumulator is Failure and currentResult is Failure => update accumulator\n        : Failure([currentResult.value]) // accumulator is Success and currentResult is Failure => return first Failure\n      : accumulator // currentResult Either is Success\n    )(currentFn(input))\n  )\n  (fns);\n\n/**\n * eitherToMaybe converts any Either monad to a Maybe monad with\n * Maybe Nothing if Either is Failure.\n *\n * @HindleyMilner eitherToMaybe :: Either -> Maybe\n *\n * @pure\n * @param {Either} eitherMonad\n * @return {Maybe}\n *\n * @example\n * import { eitherToMaybe, Either } from '@7urtle/lambda';\n *\n * eitherToMaybe(Either.Success('7urtle')); // => Just('7urtle')\n * eitherToMaybe(Either.Success(undefined)); // => Nothing\n * eitherToMaybe(Either.Failure('I am an error.')); // => Nothing\n * eitherToMaybe(Either.Failure('I am an error.')).value; // => 'I am an error.'\n */\nexport const eitherToMaybe = eitherMonad =>\n  either\n  (() => Nothing)\n  (value => Maybe.of(value))\n  (eitherMonad);\n\n/**\n * eitherToSyncEffect converts any Either monad to a SyncEffect monad with\n * error thrown on trigger if Either is Failure.\n *\n * @HindleyMilner eitherToSyncEffect :: Either -> SyncEffect\n *\n * @pure\n * @param {Either} eitherMonad\n * @return {SyncEffect}\n *\n * @example\n * import { eitherToSyncEffect, Either } from '@7urtle/lambda';\n *\n * eitherToSyncEffect(Either.Success('7urtle')).trigger(); // => '7urtle'\n * eitherToSyncEffect(Either.Failure('I am an error.')).trigger(); // throws 'I am an error.'\n */\nexport const eitherToSyncEffect = eitherMonad =>\n  either\n  (error => SyncEffect.of(() => { throw error; }))\n  (value => SyncEffect.of(() => value))\n  (eitherMonad);\n\n/**\n * eitherToAsyncEffect converts any Either monad to a AsyncEffect monad with\n * rejected error if Either is Failure.\n *\n * @HindleyMilner eitherToAsyncEffect :: Either -> AsyncEffect\n *\n * @pure\n * @param {Either} eitherMonad\n * @return {AsyncEffect}\n *\n * @example\n * import { eitherToAsyncEffect, Either } from '@7urtle/lambda';\n *\n * eitherToAsyncEffect(Either.Success('7urtle')); // resolves to '7urtle'\n * eitherToAsyncEffect(Either.Failure('I am an error.')); // rejects 'I am an error.'\n */\nexport const eitherToAsyncEffect = eitherMonad =>\n  either\n  (error => AsyncEffect.of(reject => _ => reject(error)))\n  (value => AsyncEffect.of(_ => resolve => resolve(value)))\n  (eitherMonad);","import { deepInspect } from \"./utils.js\";\nimport { nary } from \"./arity.js\";\nimport { isFunction } from \"./conditional.js\";\nimport { map } from \"./core.js\";\n\n/**\n * AsyncEffect is a monad that allows you to safely work with asynchronous side effects in JavaScript.\n *\n * AsyncEffect expects as its input a function that takes two inputs of a reject function, and a resolve\n * function. Reject function is called on failure and resolve function is called on success. It is similar\n * to using JavaScript Promise and AsyncEffect can be directly created from a Promise turning it into a monad.\n *\n * AsyncEffect is evaluated lazily and nothing is executed until a trigger function is called.\n *\n * AsyncEffect can also be called Future monad in other libraries or languages.\n *\n * @example\n * import {AsyncEffect, log, upperCaseOf, liftA2, liftA3} from '@7urtle/lambda';\n *\n * // we create AsyncEffect that expects a number from 0 to 1\n * // and based on that, it resolve or rejects 10 milliseconds after it is triggered\n * const myAsyncEffect = AsyncEffect\n * .of(reject => resolve =>\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n *\n * // we could also create AsyncEffect from a function returning JavaScript Promise\n * const myPromise = () => new Promise((resolve, reject) =>\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n * const promiseAsyncEffect = AsyncEffect.ofPromise(myPromise);\n *\n * // you can inspect AsyncEffect by\n * myAsyncEffect.inspect(); // => \"AsyncEffect(function...\n *\n * // when you are ready, you can call trigger to trigger the side effect\n * // nothing is executed until the trigger is called\n * myAsyncEffect\n * .trigger\n * (error => log(error))\n * (result => log(result));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // you can also turn AsyncEffect into a JavaScript Promise\n * myAsyncEffect\n * .promise()\n * .then(result => log(result), error => log(error));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // thrown exceptions lead AsyncEffect to reject\n * AsyncEffect\n * .of(() => {\n *     throw 'error';\n * })\n * .trigger(log)(log);\n * // => logs 'error'\n *\n * // as a functor the value inside is safely mappable\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\n * myAsyncEffect\n * .map(value => upperCaseOf(value))\n * .trigger(log)(log);\n * // => logs 'RANDOM SUCCESS' or 'random failure' depending on Math.random() value\n *\n * // as a monad AsyncEffect can be safely flat mapped with other AsyncEffects\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\n * AsyncEffect\n * .of(reject => resolve => resolve('7urtle'))\n * .flatMap(a => AsyncEffect.of(reject => resolve => resolve(a + 's')))\n * .trigger(log)(log);\n * // => logs '7urtles'\n *\n * // as an applicative functor you can apply AsyncEffects to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * const AS1 = AsyncEffect.of(reject => resolve => resolve(1));\n * const AS2 = AsyncEffect.of(reject => resolve => resolve(2));\n * liftA2(add)(AS1)(AS2); // => resolve(3)\n *\n * const ASFail = AsyncEffect.of(() => {throw 'error'});\n * liftA3(add)(ASFail)(AS1)(AS2); // => reject('error')\n *\n * // AsyncEffect.of as well as AsyncEffect.trigger accept both curried and binary functions\n * AsyncEffect.of((reject, resolve) => resolve('7urtle')).trigger(log, log); // logs '7urtle'\n *\n * // as an example you can use AsyncEffect to help you work with axios or fs\n *\n * // axios example\n * import axios from 'axios';\n * const getFromURL = url => AsyncEffect.ofPromise(() => axios.get(url));\n *\n * getFromURL('/my/ajax/url')\n * .trigger\n * (error => log(error))\n * (result => log(result.data));\n *\n * // reading file example\n * import fs from 'fs';\n * const readFile => input =>\n *     AsyncEffect\n *     .of(reject => resolve =>\n *         fs.readFile(input, (err, data) =>\n *             err ? reject(err) : resolve(data)\n *         )\n *     );\n *\n * readFile('./file.txt')\n * .trigger\n * (error => log(error))\n * (result => log(result));;\n */\nexport const AsyncEffect = {\n  of: trigger => getAsyncEffect(nary(reject => resolve => {\n    try {\n      const result = trigger(reject, resolve);\n      return isFunction(result) ? result(resolve) : result;\n    } catch(error) {\n      reject(error);\n    }\n  })),\n  ofPromise: promise => AsyncEffect.of(reject => resolve =>\n      promise().then(resolve).catch(reject)\n  )\n};\n\nconst getAsyncEffect = trigger => ({\n  trigger: trigger,\n  inspect: () => `AsyncEffect(${deepInspect(trigger)})`,\n  promise: () => new Promise((resolve, reject) => trigger(reject)(resolve)),\n  map: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(a => resolve(fn(a))))),\n  flatMap: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(x => fn(x).trigger(reject)(resolve)))),\n  ap: f => getAsyncEffect(trigger).flatMap(fn => f.map(fn))\n});\n\n/**\n * mergeAsyncEffects outputs AsyncEffect which resolves with array of all input AsyncEffects or rejects with the first effect rejected.\n *\n * @HindleyMilner mergeAsyncEffects :: ([AsyncEffect]) -> AsyncEffect\n *\n * @pure\n * @param {AsyncEffect} asyncEffects\n * @return {AsyncEffect}\n *\n * @example\n * import { mergeAsyncEffects, AsyncEffect } from '@7urtle/lambda';\n * \n * const resolvingOne = AsyncEffect.of(_ => resolve => resolve('Resolving One'));\n * const resolvingTwo = AsyncEffect.of(_ => resolve => resolve('Resolving Two'));\n *\n * mergeAsyncEffects(resolvingOne, resolvingTwo)\n * .trigger(console.log)(console.log);\n * // => logs ['Resolving One', 'Resolving Two']\n * \n * const rejectingOne = AsyncEffect.of(reject => _ => reject('Rejecting One'));\n * const rejectingTwo = AsyncEffect.of(reject => _ => reject('Rejecting Two'));\n * \n * mergeAsyncEffects(resolvingOne, rejectingOne, rejectingTwo, resolvingTwo)\n * .trigger(console.log)(console.log);\n * // => logs 'Rejecting One'\n */\nexport const mergeAsyncEffects = (...asyncEffects) =>\n  AsyncEffect\n  .ofPromise(\n      () => Promise.all(map(a => a.promise())(asyncEffects))\n  );","const token = '%[a-f0-9]{2}';\nconst singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nconst multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tconst left = components.slice(0, split);\n\tconst right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch {\n\t\tlet tokens = input.match(singleMatcher) || [];\n\n\t\tfor (let i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tconst replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD',\n\t};\n\n\tlet match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch {\n\t\t\tconst result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tconst entries = Object.keys(replaceMap);\n\n\tfor (const key of entries) {\n\t\t// Replace all decoded components\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nexport default function decodeUriComponent(encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n}\n","export default function splitOnFirst(string, separator) {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (string === '' || separator === '') {\n\t\treturn [];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n}\n","export function includeKeys(object, predicate) {\n\tconst result = {};\n\n\tif (Array.isArray(predicate)) {\n\t\tfor (const key of predicate) {\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(object, key);\n\t\t\tif (descriptor?.enumerable) {\n\t\t\t\tObject.defineProperty(result, key, descriptor);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// `Reflect.ownKeys()` is required to retrieve symbol properties\n\t\tfor (const key of Reflect.ownKeys(object)) {\n\t\t\tconst descriptor = Object.getOwnPropertyDescriptor(object, key);\n\t\t\tif (descriptor.enumerable) {\n\t\t\t\tconst value = object[key];\n\t\t\t\tif (predicate(key, value, object)) {\n\t\t\t\t\tObject.defineProperty(result, key, descriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function excludeKeys(object, predicate) {\n\tif (Array.isArray(predicate)) {\n\t\tconst set = new Set(predicate);\n\t\treturn includeKeys(object, key => !set.has(key));\n\t}\n\n\treturn includeKeys(object, (key, value, object) => !predicate(key, value, object));\n}\n","import decodeComponent from 'decode-uri-component';\nimport splitOnFirst from 'split-on-first';\nimport {includeKeys} from 'filter-obj';\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\n// eslint-disable-next-line unicorn/prefer-code-point\nconst strictUriEncode = string => encodeURIComponent(string).replaceAll(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index': {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result, [encode(key, options), '[', index, ']'].join(''),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\n\t\tcase 'bracket': {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\t[encode(key, options), '[]'].join(''),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[]=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\n\t\tcase 'colon-list-separator': {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\t[encode(key, options), ':list='].join(''),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), ':list=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\tcase 'bracket-separator': {\n\t\t\tconst keyValueSeparator = options.arrayFormat === 'bracket-separator'\n\t\t\t\t? '[]='\n\t\t\t\t: '=';\n\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Translate null to an empty string so that it doesn't serialize as 'null'\n\t\t\t\tvalue = value === null ? '' : value;\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), keyValueSeparator, encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined\n\t\t\t\t\t|| (options.skipNull && value === null)\n\t\t\t\t\t|| (options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\t...result,\n\t\t\t\t\t\tencode(key, options),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '=', encode(value, options)].join(''),\n\t\t\t\t];\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\t\t}\n\n\t\tcase 'bracket': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...accumulator[key], value];\n\t\t\t};\n\t\t}\n\n\t\tcase 'colon-list-separator': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(:list)$/.exec(key);\n\t\t\t\tkey = key.replace(/:list$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...accumulator[key], value];\n\t\t\t};\n\t\t}\n\n\t\tcase 'comma':\n\t\tcase 'separator': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : (value === null ? value : decode(value, options));\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\t\t}\n\n\t\tcase 'bracket-separator': {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = /(\\[])$/.test(key);\n\t\t\t\tkey = key.replace(/\\[]$/, '');\n\n\t\t\t\tif (!isArray) {\n\t\t\t\t\taccumulator[key] = value ? decode(value, options) : value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst arrayValue = value === null\n\t\t\t\t\t? []\n\t\t\t\t\t: value.split(options.arrayFormatSeparator).map(item => decode(item, options));\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = arrayValue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...accumulator[key], ...arrayValue];\n\t\t\t};\n\t\t}\n\n\t\tdefault: {\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [...[accumulator[key]].flat(), value];\n\t\t\t};\n\t\t}\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nexport function extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nexport function parse(query, options) {\n\toptions = {\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false,\n\t\t...options,\n\t};\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst returnValue = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn returnValue;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn returnValue;\n\t}\n\n\tfor (const parameter of query.split('&')) {\n\t\tif (parameter === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst parameter_ = options.decode ? parameter.replaceAll('+', ' ') : parameter;\n\n\t\tlet [key, value] = splitOnFirst(parameter_, '=');\n\n\t\tif (key === undefined) {\n\t\t\tkey = parameter_;\n\t\t}\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : (['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options));\n\t\tformatter(decode(key, options), value, returnValue);\n\t}\n\n\tfor (const [key, value] of Object.entries(returnValue)) {\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const [key2, value2] of Object.entries(value)) {\n\t\t\t\tvalue[key2] = parseValue(value2, options);\n\t\t\t}\n\t\t} else {\n\t\t\treturnValue[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn returnValue;\n\t}\n\n\t// TODO: Remove the use of `reduce`.\n\t// eslint-disable-next-line unicorn/no-array-reduce\n\treturn (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = returnValue[key];\n\t\tresult[key] = Boolean(value) && typeof value === 'object' && !Array.isArray(value) ? keysSorter(value) : value;\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexport function stringify(object, options) {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\t...options,\n\t};\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key]))\n\t\t|| (options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = value;\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tif (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n\t\t\t\treturn encode(key, options) + '[]';\n\t\t\t}\n\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n}\n\nexport function parseUrl(url, options) {\n\toptions = {\n\t\tdecode: true,\n\t\t...options,\n\t};\n\n\tlet [url_, hash] = splitOnFirst(url, '#');\n\n\tif (url_ === undefined) {\n\t\turl_ = url;\n\t}\n\n\treturn {\n\t\turl: url_?.split('?')?.[0] ?? '',\n\t\tquery: parse(extract(url), options),\n\t\t...(options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}),\n\t};\n}\n\nexport function stringifyUrl(object, options) {\n\toptions = {\n\t\tencode: true,\n\t\tstrict: true,\n\t\t[encodeFragmentIdentifier]: true,\n\t\t...options,\n\t};\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = extract(object.url);\n\n\tconst query = {\n\t\t...parse(queryFromUrl, {sort: false}),\n\t\t...object.query,\n\t};\n\n\tlet queryString = stringify(query, options);\n\tqueryString &&= `?${queryString}`;\n\n\tlet hash = getHash(object.url);\n\tif (typeof object.fragmentIdentifier === 'string') {\n\t\tconst urlObjectForFragmentEncode = new URL(url);\n\t\turlObjectForFragmentEncode.hash = object.fragmentIdentifier;\n\t\thash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object.fragmentIdentifier}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n}\n\nexport function pick(input, filter, options) {\n\toptions = {\n\t\tparseFragmentIdentifier: true,\n\t\t[encodeFragmentIdentifier]: false,\n\t\t...options,\n\t};\n\n\tconst {url, query, fragmentIdentifier} = parseUrl(input, options);\n\n\treturn stringifyUrl({\n\t\turl,\n\t\tquery: includeKeys(query, filter),\n\t\tfragmentIdentifier,\n\t}, options);\n}\n\nexport function exclude(input, filter, options) {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn pick(input, exclusionFilter, options);\n}\n","import * as queryString from './base.js';\n\nexport default queryString;\n","import {AsyncEffect, Either, lowerCaseOf, isNothing, upperCaseOf} from \"@7urtle/lambda\";\nimport queryString from 'query-string';\n\n/**\n * parseJSON :: String -> Either\n *\n * parseJSON parses into String to JSON returning Either functor with the result\n */\nconst parseJSON = data => Either.try(() => JSON.parse(data));\n\n/**\n * getRequestObject :: object -> object\n *\n * getRequestObject extracts request data from input requestHook and outputs request object.\n */\nconst getRequestObject = configuration => requestHook => ({\n  configuration: configuration,\n  path: requestHook.url,\n  method: lowerCaseOf(requestHook.method),\n  headers: requestHook.headers,\n  data: isNothing(requestHook.data)\n    ? undefined\n    : (json =>\n        json.isFailure()\n          ? queryString.parse(requestHook.data)\n          : json.value\n    )(parseJSON(requestHook.data))\n});\n\n/**\n * logRequest :: object -> object -> object\n *\n * logRequest uses logger for debug log of request method and url.\n */\nconst logRequest = request => {\n  request.configuration.logger.debug(`Request received for ${upperCaseOf(request.method)} ${request.path}.`);\n  return request;\n};\n\n\n/**\n * RequestEffect :: object -> object -> AsyncEffect\n *\n * RequestEffect(object)(object).trigger(d -> e, f -> g) for GET requestHook returns correct request object.\n * RequestEffect(object)(object).trigger(d -> e, f -> g) for POST requestHook returns correct request object including data.\n */\nconst RequestEffect = requestHook => configuration =>\n  AsyncEffect.of(\n    async (reject, resolve) => {\n      requestHook.data = '';\n      //requestHook.setEncoding('utf8');\n      requestHook.on('data',\n        input => {\n          configuration.logger.debug('Receiving data on request.');\n          requestHook.data += input;\n        }\n        // consider using stream-meter https://stackoverflow.com/questions/4295782/how-to-process-post-data-in-node-js\n      );\n      requestHook.on('end',\n        () => resolve(requestHook)\n      );\n    }\n  )\n  .map(getRequestObject(configuration))\n  .map(logRequest);\n\nexport default RequestEffect;\n\nexport {\n  getRequestObject,\n  logRequest,\n  parseJSON\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","import {passThrough, isJust, Either, either, identity, AsyncEffect, spy} from \"@7urtle/lambda\";\nimport fs from \"fs\";\n\n/**\n * getHeaders :: object -> object\n *\n * getHeaders creates headers object out of response object.\n * getHeaders uses text/plain content type if content-type is not specified.\n */\nconst getHeaders = response => (headers => ({\n  ...headers,\n  ...response.headers,\n  'content-type': response.contentType || 'text/plain',\n  'content-length': response.contentLength || Buffer.byteLength(response.content || response.body || '')\n}))((({configuration, data, contentType, contentLength, content, file, method, path, status, headers, ...objectData}) => objectData)(response)); // remove unwanted properties\n// TODO: we should use headers for headers, not be mixing it like this. Headers belong under headers object in the response.\n\n/**\n * sendHead :: object -> object -> Either\n */\nconst sendHead = responseHook => response =>\n  either\n  (error => passThrough(response => response.configuration.logger.error(error))(response))\n  (identity)\n  (Either.try(() =>\n    passThrough(\n      response => responseHook.writeHead(response.status || 200, getHeaders(response))\n    )(response)\n  ));\n\n/**\n * sendContent :: object -> object -> Either\n *\n * sendContent triggers responseHook.end side effect and outputs Success(responseHook) on success.\n * sendContent triggers responseHook.end side effect and outputs Failure(string) on fail.\n */\nconst sendContent = responseHook => response =>\n  Either.try(() =>\n    passThrough(\n      response =>\n        isJust(response.content)\n        ? responseHook.end(response.content)\n        : isJust(response.body)\n        ? responseHook.end(response.body)\n        : responseHook.end()\n    )(response)\n  );\n\n/**\n * streamFile :: object -> object -> (a -> b, c -> d) -> {}\n *\n * streamFile triggers read data stream side effect streaming response.file and outputs Success(responseHook) on success.\n * streamFile triggers read data stream side effect streaming response.file and outputs Failure(string) on fail.\n */\nconst streamFile = responseHook => response => (reject, resolve) =>\n  fs.existsSync(response.file)\n    ?\n    fs\n    .createReadStream(response.file)\n    .on('error', reject)\n    .on('close', () => resolve(response))\n    .pipe(responseHook)\n    : reject(new Error('Response file does not exist.'));\n\n/**\n * sendOrStream :: object -> object -> object\n *\n * sendOrStream outputs Either calling streamFile or sendContent depending on whether response.file is just.\n */\nconst sendOrStream = responseHook => response =>\n  AsyncEffect.of(\n    async (reject, resolve) =>\n      isJust(response.file)\n        ? streamFile(responseHook)(response)(reject, resolve)\n        : either(reject)(resolve)(sendContent(responseHook)(response))\n  );\n\n/**\n * ResponseEffect :: object -> object -> AsyncEffect\n */\nconst ResponseEffect = responseHook => response => {\n  sendHead(responseHook)(response);\n  return sendOrStream(responseHook)(response);\n};\n\nexport default ResponseEffect;\n\nexport {\n  getHeaders,\n  sendHead,\n  sendContent,\n  streamFile,\n  sendOrStream\n};","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  for (var key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}","import { deepInspect } from './utils.js';\nimport { nary } from './arity.js';\nimport { isNothing } from './conditional.js';\nimport { reduce } from './list.js';\nimport { Failure, Success } from './Either.js';\nimport { SyncEffect } from './SyncEffect.js';\nimport { AsyncEffect } from './AsyncEffect.js';\n\nexport const Nothing = {\n  value: null,\n  inspect: () => 'Nothing',\n  isNothing: () => true,\n  isJust: () => false,\n  map: () => Nothing,\n  flatMap: () => Nothing,\n  ap: () => Nothing\n};\n\nexport const Just = value => ({\n  value: value,\n  inspect: () => `Just(${deepInspect(value)})`,\n  isNothing: () => false,\n  isJust: () => true,\n  map: fn => Maybe.of(fn(value)),\n  flatMap: fn => fn(value),\n  ap: f => f.map(value)\n});\n\n/**\n * Maybe is one of the simplest and well known monads. Maybe is also quite similar to our monad Either.\n *\n * Maybe expects a value as its input. It is Nothing if the value is null, undefined, or empty. It returns\n * Just for all other cases.\n *\n * Maybe is called Maybe because it maybe holds a value. You want to use Maybe for situations when you don't\n * know whether there is going to be an input. For example for your API endpoint, it makes it very obvious\n * that you service may not receive a value by mistake and forces the consumer of Maybe to safely deal with it.\n *\n * In other languages, Maybe monad can also be called Option monad or Nullable monad.\n *\n * @example\n * import {maybe, Maybe, Just, Nothing, upperCaseOf, liftA2, flatMap, compose, startsWith} from '@7urtle/lambda';\n *\n * // in the example we randomly give Maybe a value or undefined. Maybe.of() outputs an instance of Maybe.\n * const myMaybe = Maybe.of(Math.random() > 0.5 ? 'random success' : undefined);\n * \n * // you can use Just and Nothing directly\n * Just('7urtle') === Maybe.of('7urtle'); // => true\n * Just('7urte') === Maybe.Just('7urtle'); // => true\n * Nothing === Maybe.of(undefined); // => true\n * Nothing === Maybe.Nothing; // => true\n *\n * // you could access the actual value like this\n * myMaybe.value; // => 'random success' or undefined\n *\n * // you can also inspect it by\n * myMaybe.inspect(); // => \"Just('random success')\" or \"Nothing\"\n *\n * // you can check if the value is Nothing\n * myMaybe.isNothing(); // => true or false\n * Maybe.of('abc').isNothing(); // => false\n * Maybe.of([]).isNothing(); // => true\n * Just('7urtle').isNothing(); // => false\n * Nothing.isNothing(); // => true\n *\n * // you can check if the value is Just\n * myMaybe.isJust(); // => true or false\n * Maybe.of(123).isJust(); // => true\n * Maybe.of(null).isJust(); // => false\n * Just('7urtle').isJust(); // => true\n * Nothing.isJust(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Nothing)\n * myMaybe.map(value => upperCaseOf(value));\n * myMaybe.inspect(); // => \"Just('RANDOM SUCCESS')\" or \"Nothing\"\n *\n * // as a monad Maybe can be safely flat mapped with other Maybes (flatMap doesn't execute over Nothing)\n * Maybe.of(3).flatMap(a => Maybe.of(a + 2)).inspect(); // => 'Just(5)'\n * Maybe.of(3).flatMap(a => Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(3).flatMap(a => a + 2); // => 5\n *\n * // as an applicative functor you can apply Maybes to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n * Maybe.of(1).map(add).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n * Maybe.of(1).map(add).ap(Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(add).ap(Maybe.of(1)).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n *\n * // as an example you can use Maybe to help you work with DOM like this\n * Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop); // => Just(1240)\n * Maybe.of(document.querySelector('#idontexist')).map(a => a.offsetTop); // => Nothing\n * maybe\n * (() => 'error: the object doesnt exist')\n * (offsetTop => 'offset from top is ' + offsetTop)\n * (Maybe.of(document?.querySelector('#iexist')?.offsetTop));\n * \n * // to read API request you can use Maybe this way\n * const getQuery = body =>\n *   flatMap\n *   (a => Maybe.of(a.queryText))\n *   (Maybe.of(body.queryResult));\n * \n * // you can use Maybe, Just, and Nothing as output of your functions\n * const maybeGetEnvironmentVariable = key => Maybe.of(process?.env?[key]);\n * const maybeDIDKeyFromEnvironment =\n *   compose(\n *     flatMap(did => startsWith('did:key')(did) ? Just(did) : Nothing),\n *     maybeGetEnvironmentVariable\n *   );\n */\nexport const Maybe = {\n  of: value => isNothing(value) ? Nothing : Just(value),\n  Just: value => Just(value),\n  Nothing: Nothing\n};\n\n/**\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n *\n * maybe can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner maybe :: (a -> b) -> (c -> d) -> Maybe -> e\n *\n * @pure\n * @param {functioon} onNothing\n * @param {function} onJust\n * @param {Maybe} functorMaybe\n * @return {*}\n *\n * @example\n * import {maybe, Maybe} from '@7urtle/lambda';\n *\n * maybe(() => 'error')(value => value)(Maybe.of('abc')); // => 'abc'\n * maybe(() => 'error')(value => value)(Maybe.of(undefined)); // => 'error'\n * maybe(() => 'error')(() => 'not error)(Maybe.of(undefined)) === Maybe.of(undefined).isNothing() ? 'error' ? 'not error';\n *\n * // maybe can be called both as a curried unary function or as a standard ternary function\n * maybe(() => 'error')(value => value)(Maybe.of('abc')) === maybe('error', value => value, Maybe.of('abc'));\n */\nexport const maybe = nary(onNothing => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? onNothing()\n    : onJust(functorMaybe.value));\n\n/**\n * mergeMaybes outputs Maybe of array with all Maybe values depending whether they are Nothing or Just.\n *\n * @HindleyMilner mergeMaybes :: ([Maybe]) -> Maybe\n *\n * @pure\n * @param {Maybe} maybes\n * @return {Maybe}\n *\n * @example\n * import { mergeMaybes, Nothing, Just, Maybe } from '@7urtle/lambda';\n *\n * mergeMaybes(Maybe.of('abc'), Just('def')); //  => Just(['abc', 'def'])\n * mergeMaybes(Maybe.of('abc'), Nothing); // => Nothing\n * mergeMaybes(Nothing, Maybe.of('def')); // => Nothing\n * mergeMaybes(Nothing, Nothing); // => Nothing\n */\nexport const mergeMaybes = (...maybes) =>\n  reduce\n  (Just([]))\n  ((accumulator, current) =>\n    current.isNothing()\n    ? Nothing\n    : accumulator.isNothing()\n      ? Nothing\n      : Just([...accumulator.value, current.value])\n  )\n  (maybes);\n\n/**\n * maybeToEither converts any Maybe monad to an Either monad with\n * 'Maybe is Nothing.' Failure if the Maybe is Nothing.\n *\n * @HindleyMilner maybeToEither :: Maybe -> Either\n *\n * @pure\n * @param {Maybe} maybeMonad\n * @return {Either}\n *\n * @example\n * import { maybeToEither, Maybe } from '@7urtle/lambda';\n *\n * maybeToEither(Maybe.of('7urtle')); // => Success('7urtle')\n * maybeToEither(Maybe.of(undefined)); // => Failure('Maybe is Nothing.')\n */\nexport const maybeToEither = maybeMonad =>\n  maybe\n  (() => Failure('Maybe is Nothing.'))\n  (value => Success(value))\n  (maybeMonad);\n\n/**\n * maybeToSyncEffect converts any Maybe monad to an SyncEffect monad with\n * 'Maybe is Nothing.' thrown error if the Maybe is Nothing.\n *\n * @HindleyMilner maybeToSyncEffect :: Maybe -> SyncEffect\n *\n * @pure\n * @param {Maybe} maybeMonad\n * @return {SyncEffect}\n *\n * @example\n * import { maybeToSyncEffect, Maybe } from '@7urtle/lambda';\n *\n * maybeToSyncEffect(Maybe.of('7urtle')).trigger(); // => '7urtle'\n * maybeToSyncEffect(Maybe.of(undefined)).trigger(); // throws 'Maybe is Nothing.'\n */\nexport const maybeToSyncEffect = maybeMonad =>\n  maybe\n  (() => SyncEffect.of(() => { throw 'Maybe is Nothing.' }))\n  (value => SyncEffect.of(() => value))\n  (maybeMonad);\n\n/**\n * maybeToAsyncEffect converts any Maybe monad to an AsyncEffect monad with\n * 'Maybe is Nothing.' reject if the Maybe is Nothing.\n *\n * @HindleyMilner maybeToAsyncEffect :: Maybe -> AsyncEffect\n *\n * @pure\n * @param {Maybe} maybeMonad\n * @return {AsyncEffect}\n *\n * @example\n * import { maybeToAsyncEffect, Maybe } from '@7urtle/lambda';\n *\n * maybeToAsyncEffect(Maybe.of('7urtle')); // resolves to '7urtle'\n * maybeToAsyncEffect(Maybe.of(undefined)); // rejects 'Maybe is Nothing.'\n */\nexport const maybeToAsyncEffect = maybeMonad =>\n  maybe\n  (() => AsyncEffect.of(reject => _ => reject('Maybe is Nothing.')))\n  (value => AsyncEffect.of(_ => resolve => resolve(value)))\n  (maybeMonad);","import {endsWith, startsWith, substr, lengthOf, isEqual, Maybe, maybe, isFunction, passThrough} from '@7urtle/lambda';\n\n/**\n * checkRoute :: string -> object -> boolean\n *\n * checkRoute outputs true if inputs path and route.path match.\n * checkRoute supports /* routes.\n */\nconst checkRoute = path => route =>\n  endsWith('/*')(route.path)\n    ? startsWith(substr(lengthOf(route.path) - 2)(0)(route.path))(path)\n    : isEqual(route.path)(path);\n\n/**\n * MaybeRoute :: object -> Maybe\n *\n * MaybeRoute outputs Maybe of route found in input request or Maybe of Nothing if route is not found.\n */\nconst MaybeRoute = request =>\n  Maybe.of(request.configuration.routes.find(checkRoute(request.path)));\n\n/**\n * emptyContent :: AsyncEffect -> AsyncEffect\n *\n * emptyContent maps AsyncEffect evaluating contentLength and making file and content values empty.\n */\nconst emptyContent = ApiEffect =>\n  ApiEffect\n  .map(result => ({\n    ...result,\n    contentLength: result.contentLength || Buffer.byteLength(result.content),\n    file: '',\n    content: ''\n  }));\n\n/**\n * rawGetApiEffect :: object -> AsyncEffect\n *\n * rawGetApiEffect outputs AsyncEffect with the response to a request based on a route.\n * rawGetApiEffect if head is not api call it outputs AsyncEffect of api call for get with empty file and content result if get is defined.\n * rawGetApiEffect if head is not api call it outputs AsyncEffect of api call for any with empty file and content result if get is not defined.\n * rawGetApiEffect outputs AsyncEffect of api 404 error for head call if head, get and any are not found.\n * rawGetApiEffect outputs AsyncEffect of api 404 error call if route is not found.\n * rawGetApiEffect outputs AsyncEffect of api any call if requested method call is not found.\n * rawGetApiEffect outputs AsyncEffect of 404 api call if both requested method call and any call are not found.\n */\nconst rawGetApiEffect = request =>\n  maybe\n  (() => request.configuration.apiError.any({...request, status: 404}))\n  (route =>\n    isFunction(route.api[request.method]) // is there api call for the request method?\n      ? route.api[request.method](request) // call api for the request method\n      : isEqual(request.method)('head') // is request method HEAD?\n      ? isFunction(route.api.get) // can I use get instead of head\n        ? emptyContent(route.api.get(request)) // use get instead of head\n        : isFunction(route.api.any) // can I used any instead of head\n          ? emptyContent(route.api.any(request)) // use any instead of head\n          : emptyContent(request.configuration.apiError.any({...request, status: 404})) // call api for 404 error\n      : isFunction(route.api.any) // is there api any function?\n        ? route.api.any(request) // call api any function\n        : request.configuration.apiError.any({...request, status: 404}) // call api for 404 error\n  )\n  (MaybeRoute(request));\n// TODO: add some automated response for OPTIONS request method\n\n/**\n * memory :: object\n *\n * memory used for default function memoization\n */\nlet memory = {};\n\n/**\n * memoizedApiEffect :: object -> object -> AsyncEffect\n */\nconst memoizedApiEffect = memory => request =>\n  (key =>\n    key in memory\n      ? memory[key]\n      : (passThrough(result => memory[key] = result))\n        (rawGetApiEffect(request))\n  )\n  (request.path + ' ' + request.method + JSON.stringify(request.data));\n  // TODO: think about using it based on some configuration\n\n/**\n * getApiEffect :: object -> AsyncEffect\n *\n * getApiEffect uses rawGetApiEffect\n */\nconst getApiEffect = rawGetApiEffect;\n\nexport default {getApiEffect};\n\nexport {\n  checkRoute,\n  MaybeRoute,\n  emptyContent,\n  rawGetApiEffect,\n  memoizedApiEffect,\n  memory\n};","import http from \"http\";\nimport {compose, isEqual, isNumber, identity} from \"@7urtle/lambda\";\nimport RequestEffect from \"./RequestEffect.js\";\nimport ResponseEffect from \"./ResponseEffect.js\";\nimport Router from \"./Router.js\";\n\n/**\n * getServer :: object -> http.Server\n *\n * getServer uses configuration object to start server with listeners for request and error\n */\nconst getServer = configuration =>\n  http\n  .createServer()\n  .on('request', configuration.listeners.request)\n  .on('error', configuration.listeners.error)\n  .listen(configuration.options.port, configuration.listeners.listening);\n\n/**\n * addListeners :: object -> object\n *\n * addListeners adds listener functions for request, error, and listening to provided configuration if not predefined.\n */\nconst addListeners = configuration => ({\n  listeners: {\n    request: requestListener(configuration),\n    error: errorListener(configuration),\n    listening: listeningListener(configuration),\n    ...configuration.listeners\n  },\n  ...configuration\n});\n\n/**\n * listeningListener :: object -> () -> string\n *\n * listeningListener uses logger provided in input configuration object to log listening event.\n */\nconst listeningListener = configuration => () =>\n  configuration.logger.info(`Server is listening on port ${configuration.options.port}.`);\n\n/**\n * errorListener :: object -> object|string -> string\n *\n * errorListener uses logger provided in input configuration object to log error listening event error object.\n */\nconst errorListener = configuration => error =>\n  isEqual(error.code)('EADDRINUSE')\n    ? configuration.logger.error(`Port ${configuration.options.port} is already in use. Server cannot start.`)\n    : configuration.logger.error(error.message || error.code || error);\n\n/**\n * respondToError :: object -> object -> number|any -> {}\n *\n * respondToError responds using ResponseHook to errors rejected during request processing.\n */\nconst respondToError = responseHook => configuration => error =>\n  isNumber(error)\n    ? configuration.logger.error(`Server request API processing failed with status: ${error}.`)\n    && respondWithApiError(configuration)(responseHook)(error)\n    : configuration.logger.error(`Server request processing failed with error: '${error}'.`)\n    && respondWithApiError(configuration)(responseHook)(500);\n\n/**\n * respondWithApiError :: object -> object -> number -> {}\n *\n * respondWithApiError triggers AsyncEffect of apiError for input status and logs potential error.\n */\nconst respondWithApiError = configuration => responseHook => status =>\n  configuration.apiError.any({\n    configuration: configuration,\n    status: status\n  })\n  .flatMap(ResponseEffect(responseHook))\n  .trigger(\n    error => configuration.logger.error(error),\n    identity\n  );\n\n/**\n * requestListener :: object -> (object, object) -> {}\n *\n * requestListener uses configuration to resolve request from requestHook by sending response using responseHook.\n */\nconst requestListener = configuration => (requestHook, responseHook) =>\n  RequestEffect(requestHook)(configuration)\n  .flatMap(Router.getApiEffect)\n  .flatMap(ResponseEffect(responseHook))\n  .trigger(\n    respondToError(responseHook)(configuration),\n    identity\n  );\n\n/**\n * create :: object -> http.Server\n *\n * create adds listeners to configuration and creates a listening http.Server.\n */\nconst create = compose(getServer, addListeners);\n\nexport default {create};\n\nexport {\n  getServer,\n  addListeners,\n  listeningListener,\n  errorListener,\n  respondToError,\n  respondWithApiError,\n  requestListener\n};","import http from 'http';\nimport {AsyncEffect, isNumber, isUndefined, compose} from '@7urtle/lambda';\n\nconst addStatusContent = request =>\n  isNumber(request.status)\n    ? ({\n      ...request,\n      content: http.STATUS_CODES[request.status]\n    })\n    : request.configuration.logger.warn('HTTP status was not provided or it is not a number. 500 status used.')\n    && ({\n      ...request,\n      status: 500,\n      content: 'Internal Server Error'\n    });\n\nconst undefinedContentTo500 = request =>\n  isUndefined(request.content)\n    ? request.configuration.logger.warn('Unknown HTTP status code number provided to apiError. 500 status used.')\n    && ({\n      ...request,\n      status: 500,\n      content: 'Internal Server Error'\n    })\n    : request;\n\nconst createApiEffect = request =>\n  AsyncEffect.of(\n    async (_, resolve) => resolve({\n      ...request,\n      contentType: 'text/plain'\n    })\n  );\n\nconst any = compose(createApiEffect, undefinedContentTo500, addStatusContent);\n\nexport default {any};","import {AsyncEffect, isEqual} from '@7urtle/lambda';\nimport fs from \"fs\";\nimport mimeTypes from \"mime-types\";\n\n/**\n * apiFile :: string -> object\n *\n * apiFile outputs api object with get call that outputs response object based on input file path.\n */\nconst apiFile = path => ({\n  get: request =>\n    AsyncEffect.of(\n      async (reject, resolve) =>\n        fs.existsSync(path)\n          ? resolve({\n            ...request,\n            status: 200,\n            file: isEqual('get')(request.method) ? path : '',\n            contentType: mimeTypes.lookup(path) || 'application/octet-stream',\n            contentLength: fs.statSync(path).size\n          })\n          : reject(404)\n    )\n});\n\nexport default apiFile;","import createLogger from \"@7urtle/logger\";\nimport Server from \"./Server.js\";\nimport apiError from \"./apis/apiError.js\";\nimport apiFile from \"./apis/apiFile.js\";\n\nconst defaultConfiguration = {\n  options: {\n    port: process.env.port || 3000\n  },\n  logger: createLogger(),\n  routes: [],\n  apiError: apiError,\n};\n\nconst start = configuration =>\n  Server.create({\n    ...defaultConfiguration,\n    ...configuration\n  });\n\nexport default {start};\n\nexport {apiFile};"],"names":["root","factory","exports","module","define","amd","this","extensions","types","preference","db","extname","EXTRACT_TYPE_REGEXP","TEXT_TYPE_REGEXP","charset","type","match","exec","mime","toLowerCase","test","charsets","lookup","contentType","str","indexOf","extension","exts","length","Object","create","path","substr","undefined","keys","forEach","i","from","source","to","require","_typeof","_regeneratorRuntime","e","__esModule","t","r","prototype","n","hasOwnProperty","o","defineProperty","value","Symbol","a","iterator","c","asyncIterator","u","toStringTag","enumerable","configurable","writable","wrap","Generator","Context","makeInvokeMethod","tryCatch","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","_invoke","AsyncIterator","invoke","resolve","__await","then","callInvokeWithMethodAndArg","Error","done","method","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","delegateYield","runtime","regeneratorRuntime","accidentalStrictMode","globalThis","Function","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","definition","key","get","obj","prop","_defineProperty","toPrimitive","String","nary","fn","args","reduce","accumulator","current","isEqual","b","isNotEqual","isTrue","deepInspect","isTypeOf","typeOf","isNotTypeOf","isString","isNull","isUndefined","isNumber","Array","isArray","isFunction","isLength","isNotElement","anything","Element","HTMLDocument","isElement","isNothing","getOwnPropertyNames","isEmpty","isJust","predicate","whenTrueFn","whenFalseFn","initial","reducer","list","reduceRight","join","checker","filter","mapper","acc","find","minusOneToUndefined","findIndex","separator","keysOf","sort","entries","every","end","start","some","compare","identity","upperCaseOf","compose","fns","map","functor","flatMap","ap1","ap2","ap","ap3","concat","includes","lastIndexOf","memory","console","log","inspectArray","inspect","k","inspectObject","inspectString","regex","string","limit","startsWith","substring","endsWith","count","repeat","replacement","replace","search","split","toUpperCase","defaultDecorator","level","message","Date","toLocaleString","configuration","levels","library","decorator","asyncGeneratorStep","gen","reject","_next","_throw","info","error","_asyncToGenerator","self","arguments","apply","err","isFailure","isSuccess","catchMap","bimap","leftFn","_","orOf","orElse","orTry","Either","try","rightFn","m","of","Success","Failure","either","onFailure","onSuccess","functorEither","trigger","getAsyncEffect","result","ofPromise","promise","catch","x","token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","decodeURIComponent","left","right","decode","input","tokens","splitOnFirst","separatorIndex","includeKeys","object","descriptor","getOwnPropertyDescriptor","Reflect","ownKeys","isNullOrUndefined","strictUriEncode","encodeURIComponent","replaceAll","charCodeAt","toString","encodeFragmentIdentifier","validateArrayFormatSeparator","encode","options","strict","encodedURI","replaceMap","customDecodeURIComponent","keysSorter","Number","removeHash","hashStart","parseValue","parseNumbers","trim","parseBooleans","extract","queryStart","parse","query","arrayFormat","arrayFormatSeparator","formatter","isEncodedArray","newValue","item","arrayValue","flat","parserForArrayFormat","returnValue","parameter","parameter_","key2","value2","Boolean","stringify","shouldFilter","skipNull","skipEmptyString","index","keyValueSeparator","encoderForArrayFormat","objectCopy","parseUrl","url","url_","hash","parseFragmentIdentifier","fragmentIdentifier","stringifyUrl","queryString","getHash","urlObjectForFragmentEncode","URL","pick","exclude","logRequest","request","logger","debug","sendHead","responseHook","response","passThrough","writeHead","status","_ref","data","contentLength","content","file","headers","_objectSpread","excluded","target","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_objectWithoutProperties","_excluded","Buffer","byteLength","body","getHeaders","sendContent","streamFile","fs","on","pipe","AsyncEffect","_ref2","_callee","_context","_x","_x2","sendOrStream","Just","Nothing","maybe","onNothing","onJust","functorMaybe","emptyContent","ApiEffect","apiError","any","route","api","Maybe","routes","lengthOf","MaybeRoute","listeningListener","port","errorListener","code","respondWithApiError","ResponseEffect","requestListener","requestHook","json","JSON","getRequestObject","RequestEffect","Router","respondToError","http","listeners","listen","listening","warn","mimeTypes","size","defaultConfiguration","process","env","getLogger","createLogger","Server"],"sourceRoot":""}